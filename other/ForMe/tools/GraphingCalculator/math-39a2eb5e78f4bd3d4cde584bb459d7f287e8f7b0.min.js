Clipping = {
    TOP: 1,
    BOTTOM: 2,
    LEFT: 4,
    RIGHT: 8,
    ALL: 15,
    X: 12,
    Y: 3,
    POLAR_RADIAN_EQUALITY: 1,
    POLAR_RADIAN_INEQUALITY: 2,
    POLAR_DEGREE_EQUALITY: 3,
    POLAR_DEGREE_INEQUALITY: 4,
    Y_EQUALS: 5,
    X_EQUALS: 6,
    mapSegmentToCanvas: function (a, b, c, d) {
        var e, f, g, h, i, j = [],
            k = b.xmin,
            l = b.ymin,
            m = b.xmax - b.xmin,
            n = b.ymax - b.ymin,
            o = c.width,
            p = c.height,
            q = o / m,
            r = -p / n,
            s = a.length;
        if (d === Clipping.Y_EQUALS) for (e = 0; e < s; e += 2) f = (a[e] - k) * q - .5, g = (a[e + 1] - l) * r + p - .5, j.push(f, g);
        else if (d === Clipping.X_EQUALS) for (e = 0; e < s; e += 2) f = (a[e + 1] - k) * q - .5, g = (a[e] - l) * r + p - .5, j.push(f, g);
        else if (d === Clipping.POLAR_RADIAN_EQUALITY) for (e = 0; e < a.length; e += 2) h = a[e], i = a[e + 1], f = (i * Math.cos(h) - k) * q - .5, g = (i * Math.sin(h) - l) * r + p - .5, j.push(f, g);
        else if (d === Clipping.POLAR_RADIAN_INEQUALITY) for (e = 0; e < a.length; e += 2) h = a[e], i = a[e + 1], i < 0 && (i = 0), f = (i * Math.cos(h) - k) * q - .5, g = (i * Math.sin(h) - l) * r + p - .5, j.push(f, g);
        else if (d === Clipping.POLAR_DEGREE_EQUALITY) for (e = 0; e < a.length; e += 2) h = a[e] * Math.PI / 180, i = a[e + 1], f = (i * Math.cos(h) - k) * q - .5, g = (i * Math.sin(h) - l) * r + p - .5, j.push(f, g);
        else if (d === Clipping.POLAR_DEGREE_INEQUALITY) for (e = 0; e < a.length; e += 2) h = a[e] * Math.PI / 180, i = a[e + 1], i < 0 && (i = 0), f = (i * Math.cos(h) - k) * q - .5, g = (i * Math.sin(h) - l) * r + p - .5, j.push(f, g);
        return j
    },
    findSingleIntersection: function (a, b, c, d, e, f, g, h) {
        var i;
        return c <= e ? (i = (e - a) / (c - a), d = d * i + b * (1 - i), c = e) : c >= g && (i = (g - a) / (c - a), d = d * i + b * (1 - i), c = g), d <= f ? (i = (f - b) / (d - b), c = c * i + a * (1 - i), d = f) : d >= h && (i = (h - b) / (d - b), c = c * i + a * (1 - i), d = h), {
            x: c,
            y: d
        }
    },
    findBothIntersections: function (a, b, c, d, e, f, g, h) {
        var i, j, k, l, m = Math.min(a, c),
            n = Math.max(a, c),
            o = Math.min(b, d),
            p = Math.max(b, d);
        return m < g && e < n && o < h && f < p ? (i = [], j = e, l = (j - a) / (c - a), k = d * l + b * (1 - l), k >= f && k <= h && i.push(j, k), j = g, l = (j - a) / (c - a), k = d * l + b * (1 - l), k >= f && k <= h && i.push(j, k), k = f, l = (k - b) / (d - b), j = c * l + a * (1 - l), j >= e && j <= g && i.push(j, k), k = h, l = (k - b) / (d - b), j = c * l + a * (1 - l), j >= e && j <= g && i.push(j, k), i.length == 4 ? i : []) : []
    },
    clipStrokeEdges: function (a, b) {
        var c, d, e, f = b.xmin,
            g = b.ymin,
            h = b.ymax,
            i = b.xmax,
            j = [],
            k = a[0],
            l = a[1],
            m = k,
            n = l,
            o = k,
            p = l,
            q = k >= f && k <= i && l >= g && l <= h;
        q && j.push(k, l);
        for (c = 2; c < a.length; c += 2) k = a[c], l = a[c + 1], q ? (q = k >= f && k <= i && l >= g && l <= h, q ? (j.push(k, l), o = k, p = l) : (m = k, n = l, d = Clipping.findSingleIntersection(o, p, m, n, f, g, i, h), j.push(d.x, d.y))) : (q = k >= f && k <= i && l >= g && l <= h, q ? (o = k, p = l, d = Clipping.findSingleIntersection(o, p, m, n, f, g, i, h), j.push(d.x, d.y)) : (e = Clipping.findBothIntersections(m, n, k, l, f, g, i, h), e.length == 4 && j.push(e[0], e[1], e[2], e[3]), m = k, n = l));
        return j
    },
    clipFillEdge: function (a, b, c) {
        var d, e, f, g, h = [],
            i = [].push,
            j = a[a.length - 2],
            k = a[a.length - 1],
            l = b(j, k);
        for (d = 0; d < a.length; d += 2) {
            e = j, f = k, g = l, j = a[d], k = a[d + 1], l = b(j, k);
            if (!l && !g) continue;
            l && g && h.push(j, k), l && !g && (i.apply(h, c(j, k, e, f)), h.push(j, k)), !l && g && i.apply(h, c(e, f, j, k))
        }
        return h
    },
    clipFillEdges: function (a, b, c) {
        var d = b.xmin,
            e = b.xmax,
            f = b.ymin,
            g = b.ymax,
            h = function (a, b) {
                return a >= d
            },
            i = function (a, b) {
                return a <= e
            },
            j = function (a, b) {
                return b >= f
            },
            k = function (a, b) {
                return b <= g
            },
            l = function (a, b, c, e) {
                var f = e - b;
                return [d, b + f * (d - a) / (c - a)]
            },
            m = function (a, b, c, d) {
                var f = d - b;
                return [e, b + f * (e - a) / (c - a)]
            },
            n = function (a, b, c, d) {
                var e = c - a;
                return [a + e * (f - b) / (d - b), f]
            },
            o = function (a, b, c, d) {
                var e = c - a;
                return [a + e * (g - b) / (d - b), g]
            },
            p = a;
        return c & Clipping.LEFT && (p = Clipping.clipFillEdge(a, h, l)), c & Clipping.BOTTOM && (p = Clipping.clipFillEdge(p, j, n)), c & Clipping.RIGHT && (p = Clipping.clipFillEdge(p, i, m)), c & Clipping.TOP && (p = Clipping.clipFillEdge(p, k, o)), p
    },
    clipAllFillEdges: function (a, b) {
        return Clipping.clipFillEdges(a, b, Clipping.ALL)
    },
    computePolarFill: function (a, b, c) {
        var d, e, f, g, h, i, j = [].push,
            k = null,
            l = [],
            m = a[0],
            n = m + c,
            o = [];
        l.push(o);
        for (d = 0; d < a.length; d += 2) e = a[d], f = a[d + 1], f < 0 && (f = 0), e >= n ? (o = [], l.push(o), m = a[d - 2], n = m + c, d -= 4) : o.push(e, f);
        if (b === 0) for (d = 0; d < l.length; d++) l[d].push(0, 0);
        else {
            g = c / 16, h = b;
            for (d = 0; d < l.length; d++) {
                i = l[d], m = i[0], n = i[i.length - 2];
                for (e = n; e > m; e -= g) i.push(e, h);
                i.push(m, h)
            }
        }
        return l
    },
    computeCartesianFill: function (a, b) {
        var c = [].push,
            d = null,
            e = [];
        return a = a.slice(), a.push(a[a.length - 2], b), a.push(a[0], b), [a]
    }
};;
Comparer = {
    isConstant: function (a) {
        var b, c, d, e, f = 1e-13,
            g = Infinity,
            h = -Infinity,
            i = getGraphedSegments(a);
        if (i && i.length == 1 && i[0].segments.length == 1 && i[0].segments[0].length >= 6) {
            d = i[0].segments[0], e = d.length;
            for (b = 0; b < e / 2; b++) c = d[2 * b + 1], g = Math.min(g, c), h = Math.max(h, c);
            return Math.abs(h - g) < f
        }
        return !1
    },
    isLine: function (a) {
        var b, c, d, e, f, g, h, i, j, k = 1e-13,
            l = getGraphedSegments(a);
        return l && l.length == 1 && l[0].segments.length == 1 && l[0].segments[0].length >= 6 ? (b = l[0].segments[0], c = b.length, j = (c - c % 4) / 2, d = b[2], e = b[3], f = b[j], g = b[j + 1], h = b[c - 2], i = b[c - 1], Math.abs(d * (g - i) + f * (i - e) + h * (e - g)) < k) : !1
    },
    isSame: function (a, b) {
        var c, d, e, f, g, h, i, j, k, l, m, n = 1e-13,
            o = getGraphedSegments(a),
            p = getSubExpressions(b);
        if (o && p && o.length > 0 && o.length == p.length) {
            for (c = 0; c < o.length; c++) for (m = 0; m < o[c].segments.length; m++) {
                d = o[c].segments[m], e = d.length, l = (e - e % 4) / 2, f = d[0], g = d[1], h = d[l], i = d[l + 1], j = d[e - 2], k = d[e - 1];
                if (Math.abs(p[m](f) - g) > n || Math.abs(p[m](h) - i) > n || Math.abs(p[m](j) - k) > n) return !1
            }
            return !0
        }
        return !1
    }
};;
Distance = {
    hypot: function (a, b) {
        return a === 0 && b === 0 ? 0 : Math.abs(a) > Math.abs(b) ? Math.abs(a) * Math.sqrt(b / a * (b / a) + 1) : Math.abs(b) * Math.sqrt(a / b * (a / b) + 1)
    },
    dot: function (a, b, c, d) {
        return a * c + b * d
    },
    pointToSegment: function (a, b, c, d, e, f) {
        var g = this.pointToSegmentParameter(a, b, c, d, e, f);
        return g <= 0 ? this.hypot(a - c, b - d) : g >= 1 ? this.hypot(a - e, b - f) : this.hypot(a - (c + g * (e - c)), b - (f + g * (f - d)))
    },
    pointToSegmentParameter: function (a, b, c, d, e, f) {
        var g, h = this.hypot(e - c, f - d);
        return h === 0 ? 0 : (g = this.dot((a - c) / h, (b - d) / h, (e - c) / h, (f - d) / h), g)
    }
};;

function smartTruncate(a) {
    return a < 0 ? Math.ceil(a) : Math.floor(a)
}
function DrawInstructions(a, b, c, d) {
    return this.stroke = a, this.hideStroke = !1, this.dashed = b, this.fill = c, this.points = d, this
}
function EnvRecord(a, b, c) {
    return this.type = a, this.name = b, this.value = c, this
}
function Intrinsic(a, b) {
    return this.func = a, this.argc = b, this
}
function Frame(a) {
    return this.predecessor = a, this.frame = {}, this.options = {}, this
}
function getGcd(a, b) {
    var c, d, e = a,
        f = b;
    e < 0 && (e = -e), f < 0 && (f = -f), f > e && (c = f, f = e, e = c), d = e % f;
    while (d > 0) e = f, f = d, d = e % f;
    return f
}
function wrapValue(a) {
    return a === undefined ? NaN : a
}
function Environment() {
    return this.intrinsic = new Frame, this.global = this.intrinsic.push(!0), this.local = this.global.push(!0), this.altLocal = null, this.set_option("integral_resolution", .01), this.set_option("integral_min_steps", 200), this.set_intrinsic("\\sqrt", 1, function (a, b) {
        return Math.sqrt(a.evalNode(b[0]))
    }), this.set_intrinsic("\\cbrt", 1, function (a, b) {
        var c = a.evalNode(b[0]);
        return (c > 0 ? 1 : -1) * Math.pow(Math.abs(c), 1 / 3)
    }), this.set_intrinsic("\\abs", 1, function (a, b) {
        return Math.abs(a.evalNode(b[0]))
    }), this.set_intrinsic("\\sin", 1, function (a, b) {
        var c = a.angle(a.evalNode(b[0]));
        return c % (Math.PI / 2) === 0 ? Math.round(Math.sin(c)) : Math.sin(c)
    }), this.set_intrinsic("\\cos", 1, function (a, b) {
        var c = a.angle(a.evalNode(b[0]));
        return c % (Math.PI / 2) === 0 ? Math.round(Math.cos(c)) : Math.cos(c)
    }), this.set_intrinsic("\\tan", 1, function (a, b) {
        var c = a.angle(a.evalNode(b[0]));
        return c % (Math.PI / 2) === 0 ? 1 / Math.round(1 / Math.round(Math.tan(c))) : Math.tan(c)
    }), this.set_intrinsic("\\sec", 1, function (a, b) {
        var c = a.angle(a.evalNode(b[0]));
        return c % (Math.PI / 2) === 0 ? 1 / Math.round(Math.cos(c)) : 1 / Math.cos(c)
    }), this.set_intrinsic("\\csc", 1, function (a, b) {
        var c = a.angle(a.evalNode(b[0]));
        return c % (Math.PI / 2) === 0 ? 1 / Math.round(Math.sin(c)) : 1 / Math.sin(c)
    }), this.set_intrinsic("\\cot", 1, function (a, b) {
        var c = a.angle(a.evalNode(b[0]));
        return c % (Math.PI / 2) === 0 ? 1 / Math.round(Math.tan(c)) : 1 / Math.tan(c)
    }), this.set_intrinsic("\\arcsin", 1, function (a, b) {
        return a.invangle(Math.asin(a.evalNode(b[0])))
    }), this.set_intrinsic("\\arccos", 1, function (a, b) {
        return a.invangle(Math.acos(a.evalNode(b[0])))
    }), this.set_intrinsic("\\arctan", 1, function (a, b) {
        return a.invangle(Math.atan(a.evalNode(b[0])))
    }), this.set_intrinsic("\\arccot", 1, function (a, b) {
        return a.invangle(Math.PI / 2 - Math.atan(a.evalNode(b[0])))
    }), this.set_intrinsic("\\arccsc", 1, function (a, b) {
        return a.invangle(Math.asin(1 / a.evalNode(b[0])))
    }), this.set_intrinsic("\\arcsec", 1, function (a, b) {
        return a.invangle(Math.acos(1 / a.evalNode(b[0])))
    }), this.set_intrinsic("\\sinh", 1, function (a, b) {
        var c = a.evalNode(b[0]);
        return (Math.pow(Math.E, c) - Math.pow(Math.E, -c)) / 2
    }), this.set_intrinsic("\\cosh", 1, function (a, b) {
        var c = a.evalNode(b[0]);
        return (Math.pow(Math.E, c) + Math.pow(Math.E, -c)) / 2
    }), this.set_intrinsic("\\tanh", 1, function (a, b) {
        var c = a.evalNode(b[0]),
            d = Math.pow(Math.E, c),
            e = Math.pow(Math.E, -c);
        return (d - e) / (d + e)
    }), this.set_intrinsic("\\sech", 1, function (a, b) {
        var c = a.evalNode(b[0]);
        return 2 / (Math.pow(Math.E, c) + Math.pow(Math.E, -c))
    }), this.set_intrinsic("\\csch", 1, function (a, b) {
        var c = a.evalNode(b[0]);
        return 2 / (Math.pow(Math.E, c) - Math.pow(Math.E, -c))
    }), this.set_intrinsic("\\coth", 1, function (a, b) {
        var c = a.evalNode(b[0]),
            d = Math.pow(Math.E, c),
            e = Math.pow(Math.E, -c);
        return (d + e) / (d - e)
    }), this.set_intrinsic("\\arccosh", 1, function (a, b) {
        var c = a.evalNode(b[0]);
        return Math.log(c + Math.sqrt(c * c - 1))
    }), this.set_intrinsic("\\arcsinh", 1, function (a, b) {
        var c = a.evalNode(b[0]);
        return Math.log(c + Math.sqrt(c * c + 1))
    }), this.set_intrinsic("\\arctanh", 1, function (a, b) {
        var c = a.evalNode(b[0]);
        return .5 * Math.log((1 + c) / (1 - c))
    }), this.set_intrinsic("\\floor", 1, function (a, b) {
        return Math.floor(a.evalNode(b[0]))
    }), this.set_intrinsic("\\ceil", 1, function (a, b) {
        return Math.ceil(a.evalNode(b[0]))
    }), this.set_intrinsic("\\round", 1, function (a, b) {
        return Math.round(a.evalNode(b[0]))
    }), this.set_intrinsic("\\min", 1, function (a, b) {
        return Math.min(a.evalNode(b[0]), a.evalNode(b[1]))
    }), this.set_intrinsic("\\max", 1, function (a, b) {
        return Math.max(a.evalNode(b[0]), a.evalNode(b[1]))
    }), this.set_intrinsic("\\list", 1, function (a, b) {
        var c, d = [];
        for (c = 0; c < b.length; c++) d.push(a.evalNode(b[c]));
        return d
    }), this.set_intrinsic("\\gcd", 2, function (a, b) {
        var c = smartTruncate(a.evalNode(b[0])),
            d = smartTruncate(a.evalNode(b[1]));
        return getGcd(c, d)
    }), this.set_intrinsic("\\lcm", 2, function (a, b) {
        var c, d = smartTruncate(a.evalNode(b[0])),
            e = smartTruncate(a.evalNode(b[1]));
        return d < 0 && (d = -d), e < 0 && (e = -e), d = Math.floor(d), e = Math.floor(e), c = getGcd(d, e), Math.abs(d * e / c)
    }), this.set_intrinsic("\\nCr", 2, function (a, b) {
        var c, d, e = Math.floor(a.evalNode(b[0])),
            f = Math.floor(a.evalNode(b[1]));
        if (f > e || e < 0 || f < 0) return 0;
        if (f == e || f == 0) return 1;
        f > e / 2 && (f = e - f), c = 1;
        for (d = 0; d < f; d++) c *= (e - d) / (d + 1);
        return c
    }), this.set_intrinsic("\\nPr", 2, function (a, b) {
        var c, d, e = Math.floor(a.evalNode(b[0])),
            f = Math.floor(a.evalNode(b[1]));
        if (f > e || e < 0 || f < 0) return 0;
        if (f == 0) return 1;
        c = 1;
        for (d = 0; d < f; d++) c *= e - d;
        return c
    }), this.set_intrinsic("\\mod", 2, function (a, b) {
        var c = a.evalNode(b[0]),
            d = a.evalNode(b[1]);
        return c % d
    }), this.set_intrinsic("\\sign", 1, function (a, b) {
        var c = a.evalNode(b[0]);
        return c > 0 ? 1 : c < 0 ? -1 : 0
    }), this.set_intrinsic("\\solvequadratic1", 3, function (a, b) {
        var c = a.evalNode(b[0]),
            d = a.evalNode(b[1]),
            e = a.evalNode(b[2]);
        if (c == 0) {
            if (d == 0 && e == 0) throw {
                error: "Too many solutions: divide by zero error."
            };
            return -1 * e / d
        }
        return d * d - 4 * c * e < 0 ? undefined : (-d + Math.sqrt(d * d - 4 * c * e)) / (2 * c)
    }), this.set_intrinsic("\\solvequadratic2", 3, function (a, b) {
        var c = a.evalNode(b[0]),
            d = a.evalNode(b[1]),
            e = a.evalNode(b[2]);
        if (c == 0) {
            if (d == 0 && e == 0) throw {
                error: "Too many solutions: divide by zero error."
            };
            return -1 * e / d
        }
        return d * d - 4 * c * e < 0 || c == 0 ? undefined : (-d - Math.sqrt(d * d - 4 * c * e)) / (2 * c)
    }), this.set_intrinsic("\\exp", 1, function (a, b) {
        return Math.exp(a.evalNode(b[0]))
    }), this.set_intrinsic("\\log", 1, function (a, b) {
        var c = a.evalNode(b[0]);
        return b.length > 1 ? Math.log(c) / Math.log(a.evalNode(b[1])) : Math.log(c) / Math.LN10
    }), this.set_intrinsic("\\ln", 1, function (a, b) {
        return Math.log(a.evalNode(b[0]))
    }), this.set_intrinsic("\\conditional", 1, function (a, b) {
        var c, d;
        for (c = 0; c < b.length; c++) {
            d = a.evalNode(b[c]);
            if (d !== undefined) return d
        }
        return undefined
    }), this.set_intrinsic("\\segment", 2, function (a, b) {
        return new DrawInstructions(DRAW_STROKE_SOLID, !1, !1, a.getArgsList(b))
    }), this.set_intrinsic("\\dsegment", 2, function (a, b) {
        return new DrawInstructions(DRAW_STROKE_SOLID, !0, !1, a.getArgsList(b))
    }), this.set_intrinsic("\\line", 2, function (a, b) {
        return new DrawInstructions(DRAW_STROKE_EXTEND, !1, !1, a.getArgsList(b))
    }), this.set_intrinsic("\\dline", 2, function (a, b) {
        return new DrawInstructions(DRAW_STROKE_EXTEND, !0, !1, a.getArgsList(b))
    }), this.set_intrinsic("\\ray", 2, function (a, b) {
        return new DrawInstructions(DRAW_STROKE_RAY, !1, !1, a.getArgsList(b))
    }), this.set_intrinsic("\\dray", 2, function (a, b) {
        return new DrawInstructions(DRAW_STROKE_RAY, !0, !1, a.getArgsList(b))
    }), this.set_intrinsic("\\rray", 2, function (a, b) {
        return new DrawInstructions(DRAW_STROKE_REVERSE_RAY, !1, !1, a.getArgsList(b))
    }), this.set_intrinsic("\\drray", 2, function (a, b) {
        return new DrawInstructions(DRAW_STROKE_REVERSE_RAY, !0, !1, a.getArgsList(b))
    }), this.set_intrinsic("\\bestfitline", 2, function (a, b) {
        return new DrawInstructions(DRAW_STROKE_BEST_FIT, !1, !1, a.getArgsList(b))
    }), this.set_intrinsic("\\dbestfitline", 2, function (a, b) {
        return new DrawInstructions(DRAW_STROKE_BEST_FIT, !0, !1, a.getArgsList(b))
    }), this.set_intrinsic("\\arc", 2, function (a, b) {
        return new DrawInstructions(DRAW_STROKE_ARC, !1, !1, a.getArgsList(b))
    }), this.set_intrinsic("\\darc", 2, function (a, b) {
        return new DrawInstructions(DRAW_STROKE_ARC, !0, !1, a.getArgsList(b))
    }), this.set_intrinsic("\\polygon", 3, function (a, b) {
        return new DrawInstructions(DRAW_STROKE_CLOSED, !1, !1, a.getArgsList(b))
    }), this.set_intrinsic("\\dpolygon", 3, function (a, b) {
        return new DrawInstructions(DRAW_STROKE_CLOSED, !0, !0, a.getArgsList(b))
    }), this.set_intrinsic("\\outline", 3, function (a, b) {
        return new DrawInstructions(DRAW_STROKE_CLOSED, !1, !1, a.getArgsList(b))
    }), this.set_intrinsic("\\doutline", 3, function (a, b) {
        return new DrawInstructions(DRAW_STROKE_CLOSED, !0, !1, a.getArgsList(b))
    }), this.set_intrinsic("\\area", 3, function (a, b) {
        return new DrawInstructions(DRAW_STROKE_NONE, !1, !0, a.getArgsList(b))
    }), this.set_intrinsic("\\dashed", 1, function (a, b) {
        var c = a.getArgsList(b)[0];
        return c.dashed = !0, c
    }), this.set_intrinsic("\\fill", 1, function (a, b) {
        var c = a.getArgsList(b)[0];
        return c.fill = !0, c
    }), this.set_intrinsic("\\nostroke", 1, function (a, b) {
        var c = a.getArgsList(b)[0];
        return c.hideStroke = !0, c
    }), this.set_constant("\\pi", Math.PI), this.set_constant("\\tau", 2 * Math.PI), this.set_constant("e", Math.E), this.formula_dict = {}, this.graph_dict = {}, this
}
function _try_solve(a, b) {
    var c;
    try {
        return c = a.solver_expression.solve_for(b), c.errors.warnings.length > 0 ? null : c.formulas
    } catch (d) {
        return null
    }
}
var DRAW_STROKE_NONE, DRAW_STROKE_SOLID, DRAW_STROKE_CLOSED, DRAW_STROKE_RAY, DRAW_STROKE_REVERSE_RAY, DRAW_STROKE_EXTEND, DRAW_STROKE_BEST_FIT, DRAW_STROKE_ARC, ENV_INTRINSIC = 0,
    ENV_USER_DEFINED = 1,
    ENV_SUBSTITUTION = 2,
    ENV_CONSTANT = 3,
    ENV_AMBIGUOUS = 4,
    ENV_INVALID = 5,
    CORE_OPERATORS = {
        "+": !0,
        "-": !0,
        "*": !0,
        "/": !0,
        "^": !0,
        "!": !0,
        "=": !0,
        "<": !0,
        ">": !0,
        "<=": !0,
        ">=": !0,
        "\\ge": !0,
        "\\le": !0,
        "\\and": !0,
        "\\or": !0,
        "\\not": !0,
        ":": !0,
        "\\hpm": !0,
        ",": !0
    },
    DRAWING_FUNCTIONS = {
        "\\segment": !0,
        "\\line": !0,
        "\\ray": !0,
        "\\rray": !0,
        "\\dsegment": !0,
        "\\dline": !0,
        "\\dray": !0,
        "\\drray": !0,
        "\\polygon": !0,
        "\\area": !0,
        "\\outline": !0,
        "\\dpolygon": !0,
        "\\doutline": !0,
        "\\bestfitline": !0,
        "\\dbestfitline": !0,
        "\\arc": !0,
        "\\darc": !0,
        "\\dashed": !0,
        "\\fill": !0,
        "\\nostroke": !0
    };
DRAW_STROKE_NONE = 0, DRAW_STROKE_SOLID = 1, DRAW_STROKE_CLOSED = 2, DRAW_STROKE_RAY = 3, DRAW_STROKE_REVERSE_RAY = 4, DRAW_STROKE_EXTEND = 5, DRAW_STROKE_BEST_FIT = 6, DRAW_STROKE_ARC = 7, Frame.prototype.angle = function (a) {
    var b = this.get_option("degree_mode");
    return b == null || !b ? a : Math.PI * a / 180
}, Frame.prototype.invangle = function (a) {
    var b = this.get_option("degree_mode");
    return b == null || !b ? a : a * 180 / Math.PI
}, Frame.prototype.getArgsList = function (a) {
    var b, c = [];
    for (b = 0; b < a.length; b++) c.push(this.evalNode(a[b]));
    return c
}, Frame.prototype.fix = function () {
    this.predecessor != null && this.predecessor._r_fix(this.frame, this.options)
}, Frame.prototype._r_fix = function (a, b) {
    var c;
    for (c in this.frame) c in a || (a[c] = this.frame[c]);
    for (c in this.options) c in b || (b[c] = this.options[c]);
    this.predecessor != null && this.predecessor._r_fix(a, b)
}, Frame.prototype.set_option = function (a, b) {
    this.options[a] = b
}, Frame.prototype.get_option = function (a) {
    return a in this.options ? this.options[a] : this.predecessor != null ? this.predecessor.get_option(a) : null
}, Frame.prototype.set = function (a, b, c) {
    if (a == ENV_INVALID || (a == ENV_SUBSTITUTION || a == ENV_USER_DEFINED) && !c.is_valid) a = ENV_INVALID, c = null;
    return b in this.frame ? (a = ENV_AMBIGUOUS, this.frame[b] = new EnvRecord(ENV_AMBIGUOUS, b, {
        newest: new EnvRecord(a, b, c),
        older: this.frame[b]
    })) : this.frame[b] = new EnvRecord(a, b, c), a
}, Frame.prototype.unset = function (a) {
    a in this.frame && delete this.frame[a]
}, Frame.prototype.push = function (a) {
    return a ? new Frame(this) : new Frame(this.predecessor)
}, Frame.prototype.get_record = function (a) {
    return a in this.frame ? this.frame[a] : this.predecessor != null ? this.predecessor.get_record(a) : null
}, Frame.prototype.evalFormula = function (a, b) {
    var c, d, e;
    if (a.alias.length > 0) {
        c = this.push();
        if (b == null || a.alias.length > b.length) throw {
            error: "Error: insufficient number of arguments to formula call."
        };
        for (d = 0; d < b.length; d++) e = a.alias[d], c.set(ENV_CONSTANT, e, this.evalNode(b[d]));
        return c.evalNode(a.get_rvalue())
    }
    return this.evalNode(a.get_rvalue())
}, Frame.prototype.evaluate = function (a, b) {
    var c, d, e, f, g, h = null;
    if (a in this.frame) h = this.frame[a];
    else {
        if (this.predecessor == null) throw {
            error: "Error: Variable not defined in current reference frame, no predecessor defined. Name: " + a
        };
        h = this.predecessor.get_record(a)
    }
    if (h == null) throw {
        error: "Error: Variable not defined in current reference frame. Name: " + a
    };
    if (h.type == ENV_CONSTANT) return c = h.value, b && b.length > 0 && (c *= this.evalNode(b[0])), c;
    if (h.type == ENV_SUBSTITUTION) return c = this.evalNode(h.value.get_rvalue()), b && b.length > 0 && (c *= this.evalNode(b[0])), c;
    if (h.type == ENV_USER_DEFINED) {
        d = this.push();
        if (b == null || h.value.alias.length > b.length) throw {
            error: "Error: insufficient number of arguments to formula call."
        };
        for (e = 0; e < b.length; e++) f = h.value.alias[e], d.set(ENV_CONSTANT, f, this.evalNode(b[e]));
        return d.evalNode(h.value.get_rvalue())
    }
    if (h.type == ENV_INTRINSIC) {
        if (b == null || h.value.argc > b.length) throw {
            error: "Error: insufficient number of arguments to formula call."
        };
        g = [];
        for (e = 0; e < b.length; e++) g.push(b[e]);
        return h.value.func(this, g)
    }
    throw h.type == ENV_AMBIGUOUS ? {
        error: "Error: Ambiguous reference: " + a
    } : {
        error: "Error: Unrecognized record type in current reference frame."
    }
}, Frame.prototype.evalNode = function (a) {
    var b = null;
    return a.type == pCONSTANT ? b = a.token : a.type == pVARIABLE ? b = this.evaluate(a.token, null) : a.type == pFUNCTION ? b = this.evaluate(a.token, a.childs) : a.type == pOPERATOR && (b = this.evalOperatorNode(a)), a.exp_node != null && (b = this.flexPow(b, a.exp_node)), a.neg_mod ? -b : b
}, Frame.prototype.evalOperatorNode = function (a) {
    return a.token in CORE_OPERATORS ? this.evalOperator(a) : a.token == "\\partial" ? this.op_partial(a) : a.token == "\\leibniz" ? this.op_leibniz(a) : a.token == "\\int" ? this.op_integral(a) : a.token == "\\sum" ? this.summation(a) : a.token == "\\prod" ? this.product(a) : this.evaluate(a.token, a.childs)
}, Frame.prototype.evalOperator = function (a) {
    var b, c, d, e, f = [];
    for (b = 0; b < a.childs.length; b++) f.push(this.evalNode(a.childs[b]));
    switch (a.token) {
    case "+":
        c = 0;
        for (b = 0; b < f.length; b++) c += f[b];
        return c;
    case "-":
        return f.length < 2 ? -f[0] : f[0] - f[1];
    case "*":
        d = 1;
        for (b = 0; b < f.length; b++) d *= f[b];
        return d;
    case "/":
        return f[1] == 0 ? NaN : f[0] / f[1];
    case "^":
        return a.childs[0].type == pFUNCTION ? (e = this.get_record(a.childs[0].token).type, e != ENV_USER_DEFINED && e != ENV_INTRINSIC ? this.evaluate(a.childs[0].token) * this.flexPow(this.evalNode(a.childs[0].childs[0]), a.childs[1]) : this.flexPow(f[0], a.childs[1])) : this.flexPow(f[0], a.childs[1]);
    case "!":
        return Environment.factorial(f[0]);
    case "=":
        return f[0] == f[1] ? 1 : undefined;
    case "<":
        return f[0] < f[1] ? 1 : undefined;
    case ">":
        return f[0] > f[1] ? 1 : undefined;
    case "\\le":
    case "<=":
        return f[0] <= f[1] ? 1 : undefined;
    case "\\ge":
    case ">=":
        return f[0] >= f[1] ? 1 : undefined;
    case "\\and":
        return f[0] > 0 && f[1] > 0 ? 1 : undefined;
    case "\\or":
        return f[0] > 0 || f[1] > 0 ? 1 : undefined;
    case "\\not":
        return f[0] > 0 ? 1 : undefined;
    case ":":
        return f[0] > 0 ? wrapValue(f[1]) : undefined;
    case "\\hpm":
        return f[1] / (Math.log(f[0]) / Math.LN10);
    case "\\hpa":
        c = 0;
        for (b = 0; b < f.length; b++) c += f[b];
        return c;
    case ",":
        return f;
    default:
        throw {
            error: "Error: Unrecognized operator."
        }
    }
}, Frame.prototype.flexPow = function (a, b) {
    var c, d, e, f, g, h;
    if (a < 0 && b.type == pOPERATOR && b.token == "/") return c = this.evalNode(b.childs[0]), d = this.evalNode(b.childs[1]), d == 0 ? undefined : c == 0 ? Math.pow(a, 0) : (e = b.neg_mod != (c < 0 != d < 0), c = Math.abs(c), d = Math.abs(d), c == Math.round(c) && d == Math.round(d) ? (f = getGcd(c, d), c /= f, d /= f, d % 2 != 0 ? c % 2 == 0 ? (g = Math.pow(-a, c * (1 / d)), e ? 1 / g : g) : (g = -Math.pow(-a, c * (1 / d)), e ? 1 / g : g) : undefined) : Math.pow(a, c * (1 / d)));
    return h = this.evalNode(b), h === 0 && a === 0 ? NaN : Math.pow(a, h)
}, Frame.prototype.op_leibniz = function (a) {
    var b, c, d, e = a.childs[0],
        f = a.childs[1];
    if (e.type != pVARIABLE) throw {
        error: "Error: d/dx notation requires a variable by which to differentiate, e.g. x."
    };
    if (f.type == pFUNCTION && this.get_record(f.token) && this.get_record(f.token).type == ENV_USER_DEFINED) return a.token = "\\partial", a.childs[1] = new ExpNode(a, f.token, pVARIABLE), f.token = ",", f.type = pOPERATOR, a.childs.push(f), f.childs[0].parent = a, this.op_partial(a);
    b = this.get_record(e.token);
    if (b == null || b.type != ENV_CONSTANT && b.type != ENV_SUBSTITUTION) throw {
        error: "Error: Sorry, we can't compute the numeric derivative if " + e.token + " is not defined as a constant."
    };
    return c = this.push(!0), d = function (a) {
        c.set(ENV_CONSTANT, e.token, a);
        var b = c.evalNode(f);
        return c.unset(e.token), b
    }, b.type == ENV_CONSTANT ? this.differentiate(d, b.value) : this.differentiate(d, this.evaluate(e.token))
}, Frame.prototype.op_partial = function (a) {
    var b, c, d, e, f, g, h, i, j, k, l = a.childs[0],
        m = a.childs[1],
        n = a.childs[2],
        o = this.get_record(m.token);
    if (o.type == ENV_INTRINSIC) {
        b = o.value;
        if (b.argc == 0) return 0;
        if (b.argc != 1) return undefined;
        if (n.type == pOPERATOR && n.token == ",") throw {
            error: "Error: Differential operator expected single argument, got argument list."
        };
        return c = this, d = function (a) {
            return b.func(c, [new ExpNode(null, a, pCONSTANT)])
        }, this.differentiate(d, this.evalNode(n))
    }
    if (o.type == ENV_USER_DEFINED) {
        e = o.value, f = e.alias, g = e.get_alias_index(l.token);
        if (g || g === 0) {
            h = null;
            if (n.type == pOPERATOR && n.token == ",") {
                h = [];
                for (i = 0; i < n.childs.length; i++) h.push(this.evalNode(n.childs[i]))
            } else h = [this.evalNode(n)];
            if (h.length < f.length) throw {
                error: "Error: insufficient parameters for function call."
            };
            j = this.push();
            for (i = 0; i < h.length; i++) i != g && j.set(ENV_CONSTANT, f[i], h[i]);
            return d = function (a) {
                j.set(ENV_CONSTANT, l.token, a);
                var b = j.evalNode(e.get_rvalue());
                return j.unset(l.token), b
            }, k = this.differentiate(d, h[g]), k
        }
        return 0
    }
    if (o.type == ENV_SUBSTITUTION) throw {
        error: "Error: differential operator not supported for substitutions, only functions."
    };
    return o.type == ENV_CONSTANT ? 0 : undefined
}, Frame.prototype.differentiate = function (a, b) {
    return (a(b + 5e-5) - a(b - 5e-5)) / 1e-4
}, Frame.prototype.op_integral = function (a) {
    var b, c, d, e, f, g, h = this.get_option("integral_resolution");
    return this.get_option("integral_min_steps") > (d - c) / h ? h = (d - c) / this.get_option("integral_min_steps") : b = a.childs[0], c = this.evalNode(a.childs[1]), d = this.evalNode(a.childs[2]), e = a.childs[3], f = this.push(), g = function (a) {
        f.set(ENV_CONSTANT, b.token, a);
        var c = f.evalNode(e);
        return f.unset(b.token), c
    }, d == c ? 0 : d < c ? -this.integrate(d, c, h, g) : this.integrate(c, d, h, g)
}, Frame.prototype.integrate = function (a, b, c, d) {
    var e, f, g, h, i = Math.ceil((b - a) / c);
    c = (b - a) / i, e = 0, f = 0, g = d(a);
    for (h = 1; h <= i; h++) f = g, g = d(a + h * c), e += (f + g) * .5 * c;
    return e
}, Frame.prototype.summation = function (a) {
    var b, c, d, e, f, g, h, i, j;
    if (a.childs.length != 3) throw {
        error: "Error: Malformed summation expression"
    };
    b = a.childs[0], c = a.childs[1], d = a.childs[2];
    if (b.token != "=") throw {
        error: "Error: Improper assignment of iterator variable."
    };
    e = b.childs[0].token, f = this.evalNode(b.childs[1]), g = this.evalNode(c);
    if (g < f) return undefined;
    h = 0, i = this;
    for (j = f; j <= g; j += 1) this.set(ENV_CONSTANT, e, j), h += i.evalNode(d), this.unset(e);
    return h
}, Frame.prototype.product = function (a) {
    var b, c, d, e, f, g, h, i, j;
    if (a.childs.length != 3) throw {
        error: "Error: Malformed product expression"
    };
    b = a.childs[0], c = a.childs[1], d = a.childs[2];
    if (b.token != "=") throw {
        error: "Error: Improper assignment of iterator variable."
    };
    e = b.childs[0].token, f = this.evalNode(b.childs[1]), g = this.evalNode(c);
    if (g < f) return undefined;
    h = 1, i = this;
    for (j = f; j <= g; j += 1) this.set(ENV_CONSTANT, e, j), h *= i.evalNode(d), this.unset(e);
    return h
}, Frame.prototype.get_references = function (a, b, c, d) {
    var e, f, g, h;
    d == null && (d = this), b == null && (b = {}), c == null && (c = {}), c[a] = !0;
    for (e in this.frame) {
        if (e in b) continue;
        f = this.frame[e];
        if (f.type == ENV_SUBSTITUTION || f.type == ENV_USER_DEFINED) b[e] = d.get_all_dependencies(f.value)
    }
    if (this.predecessor != null) return this.predecessor.get_references(a, b, c, d);
    for (e in b) {
        g = b[e];
        for (h = 0; h < g.length; h++) if (g[h] == a) {
            c[e] = !0;
            break
        }
    }
    return c
}, Frame.prototype.get_all_dependencies = function (a, b, c) {
    var d, e, f, g, h;
    b == null && (b = {}), c == null && (c = {}), d = a.dependent;
    for (e = 0; e < d.length; e++) {
        f = d[e], g = this.get_record(f);
        if (g != null) {
            if (g.type == ENV_SUBSTITUTION || g.type == ENV_USER_DEFINED) {
                if (f in c) throw {
                    error: "Error: cyclic dependency detected."
                };
                c[f] = !0, this.get_all_dependencies(g.value, b, c), delete c[f]
            }
            f in b || (b[f] = !0)
        } else f in b || (b[f] = !0)
    }
    h = [];
    for (e in b) h.push(e);
    return h
}, Frame.prototype.check_dependencies = function (a, b, c, d, e) {
    var f, g, h, i, j, k, l;
    b == null && (b = {}), d == null && (d = {}), e == null && (e = {}), c == null && (c = {}), f = a.dependent;
    for (g = 0; g < f.length; g++) {
        h = f[g], i = this.get_record(h);
        if (i != null) if (i.type == ENV_SUBSTITUTION || i.type == ENV_USER_DEFINED) {
            if (h in c) throw {
                error: "Error: cyclic dependency detected."
            };
            c[h] = !0, this.check_dependencies(i.value, b, c, d, e), delete c[h]
        } else i.type == ENV_AMBIGUOUS ? e[h] = !0 : i.type == ENV_INVALID && (d[h] = !0);
        else h in b || (b[h] = !0)
    }
    j = [];
    for (g in b) j.push(g);
    k = [];
    for (g in d) k.push(g);
    l = [];
    for (g in e) l.push(g);
    return {
        dependencies: j,
        invalid: k,
        ambiguous: l
    }
}, Environment.prototype.freeze = function () {
    this.altLocal = this.local, this.local = this.global.push(!0), this.local.fix()
}, Environment.prototype.is_frozen = function () {
    return this.altLocal != null
}, Environment.prototype.unfreeze = function () {
    this.local = this.altLocal, this.altLocal = null
}, Environment.prototype.get_option = function (a) {
    return this.intrinsic.get_option(a)
}, Environment.prototype.set_option = function (a, b) {
    this.intrinsic.set_option(a, b)
}, Environment.prototype.set_constant = function (a, b) {
    return this.intrinsic.set(ENV_CONSTANT, a, b)
}, Environment.prototype.set_intrinsic = function (a, b, c) {
    return this.intrinsic.set(ENV_INTRINSIC, a, new Intrinsic(c, b))
}, Environment.prototype.get_intrinsic = function (a) {
    return this.intrinsic.get_record(a)
}, Environment.prototype.set_global = function (a, b) {
    var c;
    return b.is_definition() && b.alias.length > 0 ? this.global.set(ENV_USER_DEFINED, a, b) : b.is_definition() && b.get_rvalue().type == pCONSTANT ? (c = b.get_rvalue(), c.exp_node != null ? this.global.set(ENV_SUBSTITUTION, a, b) : c.neg_mod ? this.global.set(ENV_CONSTANT, a, -b.get_rvalue().token) : this.global.set(ENV_CONSTANT, a, b.get_rvalue().token)) : this.global.set(ENV_SUBSTITUTION, a, b)
}, Environment.prototype.is_invalid = function (a) {
    var b = this.global.get_record(a);
    if (b == null) throw {
        error: "Record not found."
    };
    return b.type == ENV_INVALID
}, Environment.prototype.is_ambiguous = function (a) {
    var b = this.global.get_record(a);
    if (b == null) throw {
        error: "Record not found."
    };
    return b.type == ENV_AMBIGUOUS
}, Environment.prototype.set_local = function (a, b) {
    var c;
    return b.is_definition() && b.alias.length > 0 ? this.local.set(ENV_USER_DEFINED, a, b) : b.is_definition() && b.get_rvalue().type == pCONSTANT ? (c = b.get_rvalue(), c.exp_node != null ? this.local.set(ENV_SUBSTITUTION, a, b) : c.neg_mod ? this.local.set(ENV_CONSTANT, a, -b.get_rvalue().token) : this.local.set(ENV_CONSTANT, a, b.get_rvalue().token)) : this.local.set(ENV_SUBSTITUTION, a, b)
}, Environment.prototype.get_local = function (a) {
    return this.local.get_record(a)
}, Environment.prototype.unset_local = function (a) {
    this.local.unset(a)
}, Environment.prototype.evaluate = function (a, b) {
    var c, d;
    if (typeof a == "string") {
        if (b != null) {
            c = [];
            for (d = 0; d < b.length; d++) c.push(new ExpNode(null, b[d], pCONSTANT));
            return this.local.evaluate(name, c)
        }
        return this.local.evaluate(name, null)
    }
    c = [];
    if (b != null) for (d = 0; d < b.length; d++) c.push(new ExpNode(null, b[d], pCONSTANT));
    return this.local.evalFormula(a, c)
}, Environment.prototype.as_graph = function (a) {
    var b, c, d, e = null,
        f = null;
    if (typeof a == "string") {
        b = this.local.get_record(a);
        if (b == null) return null;
        e = b.type, f = b.value
    } else {
        if (!a.is_valid) throw {
            error: "syntax error"
        };
        a.alias.length == 0 ? e = ENV_SUBSTITUTION : e = ENV_USER_DEFINED, f = a
    }
    c = this;
    if (e == ENV_CONSTANT) return function () {
        return f
    };
    if (e == ENV_INTRINSIC) {
        if (f.argc == 0) return function () {
            return c.evaluate(f, [])
        };
        if (f.argc == 1) return function (a) {
            return c.evaluate(f, [a])
        };
        throw {
            error: "This expression has too many variables"
        }
    }
    if (e == ENV_SUBSTITUTION) try {
        if (f.expression.type == pOPERATOR && f.expression.token in INEQUALITY_OPS) if (f.self_reference || f.expression.childs[0].type != pVARIABLE) throw {
            error: "Sorry, we can't graph this inequality."
        };
        d = this.local.check_dependencies(f), f.variables = d.dependencies.slice();
        if (d.invalid.length > 0) throw {
            error: "Invalid dependent: " + d.invalid.toString()
        };
        if (d.ambiguous.length > 0) throw {
            error: "Ambiguous reference: " + d.ambiguous.toString()
        };
        if (f.isPointList()) {
            if (d.dependencies.length > 0) throw {
                error: "Too many undefined variables"
            };
            return function () {
                return c.evaluate(f, []), undefined
            }
        }
        if (d.dependencies.length == 0) return function () {
            return c.evaluate(f, null)
        };
        if (f.is_parametric()) {
            if (f.expression.type == pOPERATOR) throw {
                error: "Only one point allowed in parametric: "
            };
            return function (a, b) {
                var e;
                return c.local.set(ENV_CONSTANT, d.dependencies[0], a), b ? e = c.evaluate(f, null) : c.parametric_y ? e = c.local.evalNode(f.expression.childs[1]) : e = c.local.evalNode(f.expression.childs[0]), c.local.unset(d.dependencies[0]), e
            }
        }
        if (d.dependencies.length == 1) return function (a) {
            var b;
            return c.local.set(ENV_CONSTANT, d.dependencies[0], a), b = c.evaluate(f, null), c.local.unset(d.dependencies[0]), b
        };
        throw {
            error: "This expression has too many undefined variables: " + d.dependencies.join(", ") + ""
        }
    } catch (g) {
        throw g
    } else {
        if (e != ENV_USER_DEFINED) throw {
            error: "Invalid record type: " + e
        };
        try {
            d = this.local.check_dependencies(f), f.variables = d.dependencies.slice();
            if (d.dependencies.length > 0) throw {
                error: "Too many undefined variables."
            };
            if (d.invalid.length > 0) throw {
                error: "Invalid dependent: " + d.invalid.toString()
            };
            if (d.ambiguous.length > 0) throw {
                error: "Ambiguous reference: " + d.ambiguous.toString()
            };
            if (f.alias.length == 0) return function () {
                return c.evaluate(f, [])
            };
            if (f.alias.length == 1) return function (a) {
                return c.evaluate(f, [a])
            };
            throw {
                error: "This function requires too many parameters to graph, but you may still use it in other expressions."
            }
        } catch (g) {
            throw g
        }
    }
}, Environment.prototype.getFormula = function (a) {
    return this.formula_dict[a]
}, Environment.prototype.getGraphInfo = function (a) {
    return this.graph_dict[a]
}, Environment.prototype.getDependents = function (a) {
    var b, c, d, e, f = this.getFormula(a);
    if (!f) return [];
    b = f.assignment;
    if (!b) return [];
    c = this.getUpdateList(b), d = [];
    for (e = 0; e < c.length; e++) this.getFormula(c[e]).assignment != b && d.push(c[e]);
    return d
}, Environment.prototype.getUpdateList = function (a) {
    var b, c, d, e, f, g, h, i = {};
    for (b = 0; b < a.length; b++) {
        c = a[b];
        if (c == "y" || c == "x") continue;
        d = this.local.get_references(c);
        for (e in d) i[e] = !0
    }
    f = [];
    for (g in this.formula_dict) {
        h = this.formula_dict[g];
        if (h.is_definition() && h.assignment in i) f.push(g);
        else for (e = 0; e < h.dependent.length; e++) if (h.dependent[e] in i) {
            f.push(g);
            break
        }
    }
    return f
}, Environment.build = function (a, b) {
    var c, d, e, f, g, h, i, j, k, l = new Environment;
    l.set_option("degree_mode", b.degree_mode), e = {}, f = [];
    for (c in a) {
        d = Formula.fromLatex(a[c].latex), d.domain = a[c].domain, l.formula_dict[c] = d;
        if (d.is_assignable()) l.global.get_record(d.assignment) != null ? f.push(d) : l.set_global(d.assignment, d);
        else if (d.expression != null && (d.expression.token == "\\list" || d.expression.containsList()) && !d.expression.isPointList()) if (d.expression.token == "\\list") d.expression.containsList() ? d.error = "Sorry, you can't nest points in other points." : d.error = "Points must have exactly two coordinates, e.g. [1,2].";
        else if (d.expression.token == ",") {
            g = !1;
            for (h = 0; h < d.expression.childs.length; h++) {
                i = d.expression.childs[h];
                if (i.containsList()) {
                    d.error = "Sorry, you can't nest points in other points.", g = !0;
                    break
                }
                if (i.childs.length != 2) {
                    d.error = "Points must have exactly two coordinates, e.g. [1,2].", g = !0;
                    break
                }
            }
            g || (d.error = "Point lists need to look like this: [a,b],[c,d]... ")
        } else d.error = "Point lists need to look like this: [a,b],[c,d]... ";
        else d.assignment == null && d.is_valid && d.has_comparer() && f.push(d)
    }
    Environment.solve(l, f);
    for (c in a) {
        d = l.formula_dict[c];
        if (d.containsError()) continue;
        j = d.getFormulas();
        for (k = 0; k < j.length; k++) if (!Environment.addAsGraph(l, c, j[k])) break
    }
    return l
}, Environment.solve = function (a, b) {
    var c, d, e, f, g, h, i, j, k, l, m = !1;
    do {
        m = !1, d = [];
        for (e = 0; e < b.length; e++) {
            c = b[e], c.deconvert_implicit_multiplications(a), f = a.global.check_dependencies(c);
            if (f.invalid.length > 0 || f.ambiguous.length > 0) continue;
            if (f.dependencies.length == 0) continue;
            if (f.dependencies.length == 1) {
                g = f.dependencies[0];
                try {
                    if (c.comparer == null || c.comparer != "=") throw {
                        error: "Sorry, the solver can't solve inequalities."
                    };
                    h = c.solver_expression.solve_for(g);
                    if (h.errors.warnings.length > 0) {
                        c.error = h.errors.warnings[0];
                        continue
                    }
                    i = [];
                    for (j = 0; j < h.formulas.length; j++) try {
                        k = a.local.evalNode(h.formulas[j].expression.childs[1]), i.push(k)
                    } catch (n) {
                        continue
                    }
                    if (i.length == 1 || i.length == 2 && i[0] == i[1]) g != "y" && g != "x" && g != "r" && g != "\\theta" && a.global.set(ENV_CONSTANT, g, i[0]), c.subformulas = [Formula.constFormula(g, i[0])], m = !0;
                    else if (i.length == 2) g != "y" && g != "x" && g != "r" && g != "\\theta" && (a.global.set(ENV_CONSTANT, g, i[0]), a.global.set(ENV_CONSTANT, g, i[1])), c.subformulas = [Formula.constFormula(g, i[0]), Formula.constFormula(g, i[1])], m = !0;
                    else if (i.length == 0) {
                        g != "y" && g != "x" && "r" && g != "\\theta" && a.global.set(ENV_INVALID, g, null);
                        continue
                    }
                } catch (n) {
                    c.error = n.error;
                    continue
                }
            } else if (f.dependencies.length == 2 && (__is_in_list(c.dependent, "y") || __is_in_list(c.dependent, "x") || __is_in_list(c.dependent, "r"))) {
                if (c.comparer == null || c.comparer != "=") {
                    c.error = "Sorry, the solver can't solve inequalities.";
                    continue
                }
                l = null, __is_in_list(c.dependent, "y") && (l = _try_solve(c, "y"), l != null && l.length != 0 && (c.subformulas = l, m = !0)), l == null && __is_in_list(c.dependent, "x") && (l = _try_solve(c, "x"), l != null && l.length != 0 && (c.subformulas = l, m = !0)), l == null && __is_in_list(c.dependent, "r") && (l = _try_solve(c, "r"), l != null && l.length != 0 && (c.subformulas = l, m = !0)), c.error = "Sorry, couldn't solve this equation because there were too many unknowns."
            } else d.push(c)
        }
        b = d
    } while (m)
}, Environment.addAsGraph = function (a, b, c) {
    var d, e;
    try {
        d = a.as_graph(c);
        if (d == null) throw {
            error: "unknown error: not a valid graph"
        };
        c.alias == 0 ? c.is_parametric() ? c.zero_value = d(0, !0) : c.zero_value = d(0) : c.zero_value = null, e = a.graph_dict[b], e || (e = a.graph_dict[b] = []), e.push({
            expr: d,
            formula: c
        })
    } catch (f) {
        return c.error = f.error, !1
    }
    return !0
}, Environment.compare = function (a, b) {
    var c, d, e, f, g, h, j = a.formula_dict,
        k = b.formula_dict,
        l = a.get_option("degree_mode") != b.get_option("degree_mode"),
        m = {},
        n = {};
    for (d in k) {
        e = !j[d] || j[d].domain.min != k[d].domain.min || j[d].domain.max != k[d].domain.max;
        if (!j[d] || j[d].latex != k[d].latex || l || e) f = k[d], n[d] = f, c = f.assignment, c && (m[c] = !0), j[d] && (c = j[d].assignment, c && (m[c] = !0))
    }
    for (d in j) d in k || (n[d] = null, c = j[d].assignment, c && (m[c] = !0));
    g = [];
    for (d in m) g.push(d);
    h = b.getUpdateList(g);
    for (i = 0; i < h.length; i++) d = h[i], d in n || (n[d] = k[d]);
    return n
}, Environment.factorial = function (a) {
    switch (a) {
    case 0:
        return 1;
    case 1:
        return 1;
    case 2:
        return 2;
    case 3:
        return 6;
    case 4:
        return 24;
    case 5:
        return 120;
    case 6:
        return 720;
    case 7:
        return 5040;
    case 8:
        return 40320;
    case 9:
        return 362880;
    case 10:
        return 3628800;
    case 11:
        return 39916800;
    case 12:
        return 479001600;
    case 13:
        return 6227020800;
    case 14:
        return 87178291200;
    case 15:
        return 1307674368e3;
    case 16:
        return 20922789888e3;
    case 17:
        return 355687428096e3;
    case 18:
        return 6402373705728e3;
    case 19:
        return 0x1b02b9306890000;
    case 20:
        return 243290200817664e4;
    case 21:
        return 0x3ceea4c2b3e0d80000;
    default:
        return Environment.gamma(a + 1)
    }
}, Environment.gamma = function (a) {
    return a <= 0 && parseInt(a) == a ? NaN : a < 0 ? -Math.PI / (a * Math.sin(Math.PI * a) * Environment.gamma(-a)) : Math.exp(Environment.gammaln(a))
}, Environment.gammaln = function (a) {
    var b, c, d, e, f, g = [57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 3399464998481189e-20, 4652362892704858e-20, -0.00009837447530487956, .0001580887032249125, -0.00021026444172410488, .00021743961811521265, -0.0001643181065367639, 8441822398385275e-20, -0.000026190838401581408, 36899182659531625e-22];
    if (a <= 0) return NaN;
    e = a, c = a, d = c + 5.2421875, d = (c + .5) * Math.log(d) - d, f = .9999999999999971;
    for (b = 0; b < 14; b++) f += g[b] / ++e;
    return d + Math.log(2.5066282746310007 * f / c)
};;

function EvalWorker(a) {
    var b;
    this.thread = a, a || (this.fake_queue = [], this.onmessage = function () {}, b = this, this.onTick = function () {
        b.fake_queue.length && b.processMessage(b.fake_queue.shift(), b.onmessage, !0), setTimeout(b.onTick, 4)
    }, setTimeout(this.onTick, 4))
}
var POI_ZERO = 0,
    POI_MIN = 1,
    POI_MAX = 2,
    POI_JUMP = 3,
    POI_INTERCEPT = 4,
    POI_INTERSECTION = 5,
    PLOT_EXTREMA = 1,
    PLOT_ZEROS = 2,
    PLOT_JUMPS = 4,
    PLOT_INTERSECTIONS = 8,
    PLOT_INTERCEPTS = 16;
EvalWorker.prototype.graph = function (a, b, c) {
    var d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H = [],
        I = [];
    try {
        this.env.freeze(), H = this.env.getGraphInfo(a);
        if (!H) return I;
        for (f = 0; f < H.length; f++) {
            d = H[f].formula, e = H[f].expr, g = d.graph_mode(), h = g == GRAPHMODE_X;
            if (g == GRAPHMODE_XYPOINT) i = H[f], I.push({
                segments: [this.env.evaluate(i.formula, [])],
                graphMode: g,
                poi: [],
                operator: "=",
                expr_i: f
            });
            else if (g == GRAPHMODE_PARAMETRIC) {
                j = d.domain;
                if (!j) return;
                k = j.min, l = j.max;
                if (!isFinite(l) || !isFinite(k)) return;
                E = EvalWorker.sampleAndSegmentParametricGraph(e, k, l, b), I.push({
                    segments: E,
                    graphMode: g,
                    poi: [],
                    operator: "=",
                    expr_i: f
                })
            } else D = EvalWorker.sampleGraph(H[f], b, this.env), E = EvalWorker.segmentGraph(e, D), F = EvalWorker.findPOI(E, e, g, b, c.settings), G = EvalWorker.findIntersections(H[f], a, b, this.env, c), I.push({
                segments: E,
                graphMode: g,
                poi: F,
                intersections: G,
                operator: d.get_operator(),
                expr_i: f
            })
        }
        return I
    } finally {
        this.env.unfreeze()
    }
}, EvalWorker.prototype.environment = function (a, b) {
    return this.env = Environment.build(a, b), !0
}, EvalWorker.prototype.postMessage = function (a) {
    this.thread ? this.processMessage(a, this.thread.postMessage, !1) : this.fake_queue.push(a)
}, EvalWorker.prototype.processMessage = function (a, b, c) {
    var d = null;
    switch (a.cmd) {
    case "graph":
        d = {
            cmd: a.cmd,
            result: this.graph(a.id, a.window, a.poi)
        };
        break;
    case "environment":
        d = {
            cmd: a.cmd,
            result: this.environment(a.expressions, a.options)
        }
    }
    c && (d = {
        data: d
    }), b(d)
}, EvalWorker.prototype.terminate = function () {
    this.env_version = null, this.fake_queue = [], this.job = null, this.startTime = null
}, EvalWorker.sampleGraph = function (a, b, c) {
    var d, e, f, g, h, i, j, k, l, m = a.formula,
        n = a.expr,
        o = m.graph_mode(),
        p = o == GRAPHMODE_X,
        q = b.viewport,
        r = b.screen;
    if (o == GRAPHMODE_POLAR) {
        d = c.get_option("degree_mode") ? 180 : Math.PI, e = n(1.23), f = 24 * d;
        if (m.get_operator() != "=") for (g = 2; g <= 12; g += 2) {
            h = n(1.23 + d * g);
            if (Math.abs(h - e) < 1e-11) {
                f = g * d;
                break
            }
        } else for (g = 1; g <= 12; g++) {
            h = n(1.23 + d * g) * (g % 2 == 0 ? 1 : -1);
            if (Math.abs(h - e) < 1e-11) {
                f = g * d;
                break
            }
        }
        f > 12 * d && (f = 12 * d), i = f / 6007, i = Math.min(.009 * (d / Math.PI), i), i = Math.max(.003 * (d / Math.PI), i), j = [];
        for (k = 0; k <= f; k += i) j.push(k), j.push(n(k));
        return k != f && (k = f, j.push(k), j.push(n(k))), k = f + 1e-10, j.push(k), j.push(n(k)), j
    }
    p ? i = (q.y[1] - q.y[0]) / r.height : i = (q.x[1] - q.x[0]) / r.width, i *= .5, l = q[p ? "y" : "x"][0], f = q[p ? "y" : "x"][1], j = [];
    for (k = l; k <= f; k += i) j.push(k), j.push(n(k));
    return k != f && (k = f, j.push(k), j.push(n(k))), j
}, EvalWorker.createAccumulator = function () {
    return {
        segments: [],
        segment: null,
        n: 0,
        addPoint: function (a) {
            this.n += 1, this.segment ? this.segment.push(a[0], a[1]) : this.segment = [a[0], a[1]]
        },
        breakSegment: function () {
            this.segment && (this.segment.length > 2 && this.segments.push(this.segment), this.segment = null)
        }
    }
}, EvalWorker.sampleAndSegmentParametricGraph = function (a, b, c, d) {
    var e, f, g, h, i, j, k, l, m = EvalWorker.createAccumulator(),
        n = 1e3,
        o = 10,
        p = c - b;
    if (p <= 0) return [];
    e = (d.viewport.x[1] - d.viewport.x[0]) / d.screen.width, f = (d.viewport.y[1] - d.viewport.y[0]) / d.screen.height, g = Math.min(e, f) * .5, h = b;
    for (i = 0; i < n; i++) j = h, h = b + (i + 1) / n * p, k = a(j, !0), l = a(h, !0), isFinite(k[0]) && isFinite(k[1]) && m.addPoint(k), EvalWorker.recursiveSampleParametricGraph(a, j, k, h, l, o, m, g);
    return m.breakSegment(), m.segments
}, EvalWorker.recursiveSampleParametricGraph = function (a, b, c, d, e, f, g, h) {
    var i, j, k, l, m, n, o, p, q, r;
    if (f == 0) {
        g.breakSegment();
        return
    }
    if (d == b) return;
    if (c[0] === e[0] && c[1] === e[1]) return;
    i = isFinite(c[0]) && isFinite(c[1]), j = isFinite(e[0]) && isFinite(e[1]);
    if (i != j) {
        k = b, l = d, m = c, n = e, o = b + (d - b) / 2, p = a(o, !0), q = isFinite(p[0]) && isFinite(p[1]);
        while (b !== o && o !== d) q == i ? (b = o, c = p, i = q) : (d = o, e = p, j = q), o = b + (d - b) / 2, p = a(o, !0), q = isFinite(p[0]) && isFinite(p[1]);
        i ? (EvalWorker.recursiveSampleParametricGraph(a, k, m, b, c, f - 1, g, h), g.breakSegment()) : (g.breakSegment(), g.addPoint(e), EvalWorker.recursiveSampleParametricGraph(a, d, e, l, n, f - 1, g, h));
        return
    }
    if (!i && !j) return;
    o = b + (d - b) / 2, p = a(o, !0);
    if (i && j) {
        r = Distance.pointToSegmentParameter(p[0], p[1], c[0], c[1], e[0], e[1]);
        if (r > .2 && r < .8 && Distance.hypot(p[0] - (c[0] + r * (e[0] - c[0])), p[1] - (c[1] + r * (e[1] - c[1]))) < h) {
            g.addPoint(e);
            return
        }
    }
    EvalWorker.recursiveSampleParametricGraph(a, b, c, o, p, f - 1, g, h), EvalWorker.recursiveSampleParametricGraph(a, o, p, d, e, f - 1, g, h)
}, EvalWorker.segmentGraph = function (a, b) {
    var c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C = [],
        D = null,
        E = 1e-9,
        F = .01,
        G = .001,
        H = Math.pow(10, 13);
    (b[1] >= 0 || b[1] < 0) && C.push(D = [b[0], b[1]]);
    for (p = 2, q = b.length - 4; p <= q; p += 4) {
        f = b[p - 2], g = b[p - 1], h = g >= 0 || g < 0, c = b[p], d = b[p + 1], e = d >= 0 || d < 0, i = b[p + 2], j = b[p + 3], k = j >= 0 || j < 0;
        if (h && k) {
            r = !0, s = NaN, t = NaN, l = d - g, m = j - d;
            if (l != m && Math.abs(l - m) / Math.max(Math.abs(l), Math.abs(m)) > .25) {
                while ((o = i - f) > E) l = d - g, m = j - d, t = s, Math.abs(l) > Math.abs(m) ? (s = l, i = c, j = d) : (s = m, f = c, g = d), c = (i + f) / 2, d = a(c);
                if (Math.abs(s) > Math.abs(t) && Math.abs(s) / o > H) r = !1, D && D.push(f, g), C.push(D = [i, j]);
                else if (Math.abs((s - t) / s) < G && Math.abs(s) / E > 10) r = !1, D && D.push(f, g), C.push(D = [i, j]);
                else {
                    r = !1, u = b[p - 2], v = u, w = b[p - 1], x = w, y = (b[p + 2] - u) / 30, z = b[p + 2];
                    for (A = u; A <= z; A += y) B = a(A), B > x ? (x = B, v = A) : B < w && (w = B, u = A);
                    u > v && (z = u, u = v, v = z, z = w, w = x, x = z), u > b[p - 2] && (D ? D.push(u, w) : C.push(D = [u, w])), v < b[p + 2] && (D ? D.push(v, x) : C.push(D = [v, x]))
                }
            }
            r && (D ? D.push(i, j) : C.push(D = [i, j]))
        } else h && !k ? (n = EvalWorker.traceApproach(a, f, i), n && (D ? D.push(n.x, n.y) : C.push(D = [n.x, n.y]))) : !h && k && (n = EvalWorker.traceApproach(a, i, f), n && C.push(D = [n.x, n.y, i, j]))
    }
    return b.length % 4 == 0 && (c = b[b.length - 2], d = b[b.length - 1], !isNaN(c) && !isNaN(d) && D.push(c, d)), C
}, EvalWorker.traceApproach = function (a, b, c) {
    var d = a(b),
        e = a(c),
        f = b + (c - b) / 2,
        g = a(f);
    if (!isFinite(b) || !isFinite(c)) return null;
    while (b !== f && f !== c) isFinite(d) !== isFinite(g) ? (c = f, e = g) : (b = f, d = g), f = b + (c - b) / 2, g = a(f);
    return isFinite(d) ? {
        x: b,
        y: d
    } : {
        x: c,
        y: e
    }
}, EvalWorker.findIntersections = function (a, b, c, d, e) {
    var f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = e.settings;
    if (!(u & PLOT_INTERSECTIONS)) return {};
    f = a.formula.graph_mode(), g = f == GRAPHMODE_X;
    if (f != GRAPHMODE_Y && f != GRAPHMODE_X) return {};
    h = a.expr, i = {}, i.formula = a.formula, j = {}, k = e.graphed;
    for (l in k) {
        if (l == b) continue;
        m = d.getGraphInfo(l);
        if (!m) continue;
        n = [];
        for (o = 0; o < m.length; o++) {
            p = m[o];
            if (p.formula.graph_mode() != f) continue;
            i.expr = function (a) {
                return h(a) - p.expr(a)
            }, q = EvalWorker.sampleGraph(i, c, this.env), r = EvalWorker.segmentGraph(i.expr, q), s = EvalWorker.findPOI(r, i.expr, f, c, PLOT_ZEROS);
            if (g) for (t = 2; t < s.length; t += 3) n.push(h(s[t]), s[t]);
            else for (t = 1; t < s.length; t += 3) n.push(s[t], h(s[t]))
        }
        n.length && (j[l] = n)
    }
    return j
}, EvalWorker.findPOI = function (a, b, c, d, e) {
    var f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S;
    if (c != GRAPHMODE_X && c != GRAPHMODE_Y) return [];
    f = c == GRAPHMODE_X, g = d.viewport, h = e & PLOT_EXTREMA, i = e & PLOT_ZEROS, j = e & PLOT_JUMPS, k = e & PLOT_INTERCEPTS;
    if (!h && !i && !j && !k) return [];
    l = {
        xmin: g.x[0],
        xmax: g.x[1],
        ymin: g.y[0],
        ymax: g.y[1]
    }, m = (l.xmax - l.xmin) / 20, n = (l.ymax - l.ymin) / 20, o = l.xmin - m, p = l.xmax + m, q = l.ymin - n, r = l.ymax + n, t = l.xmin, u = l.xmax, f && (s = o, q = o, o = s, s = p, r = p, p = s, t = l.ymin, u = l.ymax), v = d.screen.width, w = 10, x = (p - o) / v * w, y = {
        x: (p - o) / v,
        y: 1e-7
    }, z = [], k && o < 0 && p > 0 && (L = b(0), (L >= 0 || L <= 0) && z.push(POI_INTERCEPT, 0, L)), A = 0, B = -Infinity, C = -Infinity, D = -Infinity, E = null, F = null, G = 0;
    for (A = 0; A < a.length; A++) {
        H = a[A], I = H[0], K = H[1], O = 2, (j || i) && I > t && (A > 0 || isNaN(b(t))) && K <= r && K >= q && (j && z.push(POI_JUMP, I, K), i && Math.abs(K) < y.y && I - D > x && EvalWorker.zeroNotFlat(b, I, y) && (z.push(POI_ZERO, I, 0), D = I)), P = -Infinity;
        for (Q = 0; Q < H.length; Q += 2) {
            J = H[Q], L = H[Q + 1];
            if (O == 0) {
                N = L == K ? 0 : L > K ? 1 : -1;
                if (N != 0 && N == -M) if (h && i) {
                    R = N == 1 && J - C > x || N == -1 && J - B > x, S = J - D > x;
                    if (R || S) E = EvalWorker.pinpointExtrema(b, H[Q - 4], I, J), E && (R && (z.push(E.type, E.x, E.y), N == 1 ? C = J : B = J), S && Math.abs(E.y) < y.y && EvalWorker.zeroNotFlat(b, J, y) && (z.push(POI_ZERO, E.x, 0), D = J))
                } else if (h) {
                    if (N == 1 && J - C > x || N == -1 && J - B > x) E = EvalWorker.pinpointExtrema(b, H[Q - 4], I, J), E && (z.push(E.type, E.x, E.y), N == 1 ? C = J : B = J)
                } else i && J - D > x && (E = EvalWorker.pinpointExtrema(b, H[Q - 4], I, J), E && Math.abs(E.y) < y.y && EvalWorker.zeroNotFlat(b, J, y) && (z.push(POI_ZERO, E.x, 0), D = J));
                M = N;
                if (i && J - D > x) if (L == 0 && K != 0) EvalWorker.zeroNotFlat(b, J, y) && (z.push(POI_ZERO, J, 0), D = J);
                else if (L > 0 && K < 0 || L < 0 && K > 0) F = EvalWorker.pinpointZero(b, I, J), F && EvalWorker.zeroNotFlat(b, F.x, y) && (z.push(POI_ZERO, F.x, F.y), D = J)
            } else O--, O == 0 && (M = L == K ? 0 : L > K ? 1 : -1);
            I = J, K = L
        }
        j && I < u && (A + 1 < a.length || isNaN(b(u))) && K <= r && K >= q && z.push(POI_JUMP, I, K)
    }
    if (f) for (A = z.length - 1; A >= 0; A -= 3) s = z[A], z[A] = z[A - 1], z[A - 1] = s;
    return z
}, EvalWorker.zeroNotFlat = function (a, b, c) {
    return Math.abs(a(b - c.x)) > c.y || Math.abs(a(b + c.x)) > c.y
}, EvalWorker.pinpointZero = function (a, b, c) {
    var d = a(b),
        e = a(c),
        f = b + (c - b) / 2,
        g = a(f);
    if (!isFinite(b) || !isFinite(c)) return null;
    while (b !== f && f !== c && g !== 0) {
        if (d < 0 != g < 0) c = f, e = g;
        else {
            if (g < 0 == e < 0) break;
            b = f, d = g
        }
        f = b + (c - b) / 2, g = a(f)
    }
    return isFinite(d) && isFinite(e) ? Math.abs(d) < Math.abs(e) ? {
        x: b,
        y: 0,
        type: POI_ZERO
    } : {
        x: c,
        y: 0,
        type: POI_ZERO
    } : null
}, EvalWorker.pinpointExtrema = function (a, b, c, d) {
    var e = a(b),
        f = a(c),
        g = a(d),
        h = b + (c - b) / 2,
        i = c + (d - c) / 2,
        j = a(h),
        k = a(i),
        l = e < f ? POI_MAX : POI_MIN;
    if (!(isFinite(b) && isFinite(c) && isFinite(d))) return null;
    while (b !== h && h !== c && c !== i && i !== d && j !== f && f !== k) {
        if (j > e == j > f) d = c, g = f, c = h, f = j;
        else if (f > j == f > k) b = h, e = j, d = i, g = k;
        else {
            if (k > f != k > g) break;
            b = c, e = f, c = i, f = k
        }
        h = b + (c - b) / 2, i = c + (d - c) / 2, j = a(h), k = a(i)
    }
    return isFinite(f) ? {
        x: c,
        y: f,
        type: l
    } : null
}, EvalWorker.isSpecialNumber = function (a, b, c, d) {
    var e, f, g, h, i, j, k, l, m, n, o;
    if (a > 1e3) return "";
    c ? c = Math.max(1, c) : c = 1, e = [2, 3, 5], f = Math.PI, g = Math.round(24 * c * (d ? 65536 : 1)), a /= f, a *= g, h = g, i = (Math.round(a) - a) / a;
    if (Math.abs(i) > b) return null;
    j = Math.round(a), k = g;
    if (j === 0) return null;
    for (l = 0; l < e.length; l++) {
        m = e[l];
        while (j % m == 0 && k % m == 0 && k > 1 && Math.abs(j) > 1) j /= m, k /= m
    }
    return k > h ? "" : (j == 1 ? n = "" : j == -1 ? n = "-" : n = String(j), k == 1 ? o = "" : o = "/" + k, j == 0 && k == 0 ? null : {
        str: n + "" + o,
        num: j * f / k
    })
};;

function __is_in_list(a, b, c) {
    var d;
    if (!c) {
        for (d = 0; d < a.length; d++) if (b == a[d]) return !0
    } else {
        b = b.toLowerCase();
        for (d = 0; d < a.length; d++) if (b == a[d].toLowerCase()) return !0
    }
    return !1
}
function ExpNode(parnt, tk, tp) {
    return this.parent = parnt, this.childs = [], tp == pCONSTANT ? this.token = eval("(" + tk.toString() + ")") : this.token = tk, this.type = tp, this.neg_mod = !1, this.treat_as_constant = !1, this.exp_node = null, this
}
function WarningBuffer() {
    return this.infos = [], this.warnings = [], this.errors = [], this
}
function prefixCopy(a, b) {
    var c, d = [];
    for (c = 0; c < a.length; c++) d.push(a[c].clone());
    return d.push(b.clone()), d
}
function lazyAdd(a, b, c, d) {
    var e = !1;
    return b in a ? e = !0 : a[b] = 0, d ? a[b] -= c : a[b] += c, e
}
function lazyAccumulateExponent(a, b, c) {
    b in a ? a[b].push(c) : a[b] = [c]
}
function accumulateExponent(a, b, c, d) {
    var e, f, g, h;
    if (b.treat_as_constant) lazyAccumulateExponent(a, 0, b);
    else if (b.type == pVARIABLE && b.token == c) e = new ExpNode(null, 1, pCONSTANT), b.neg_mod && (e.token = -1), b.exp_node == null ? lazyAccumulateExponent(a, 1, e) : b.exp_node.is_integer_exact() ? lazyAccumulateExponent(a, b.exp_node.token, e) : d.error("This solver can't handle non-integral and non-constant powers of the variable to solve for.");
    else if (b.type == pOPERATOR && b.token == "+") d.error("Rogue addition in the canonical form.");
    else if (b.type == pOPERATOR && b.token == "*") for (f = 0; f < b.childs.length; f++) {
        g = b.childs[f];
        if (g.type == pVARIABLE && g.token == c) {
            g.neg_mod && (g.neg_mod = !1, b.neg_mod = !b.neg_mod);
            if (g.exp_node == null) {
                b.remove_child_at(f), b.treat_as_constant = !0, b.type == pOPERATOR && b.token == "*" && b.childs.length == 1 && (b.childs[0].neg_mod = b.childs[0].neg_mod != b.neg_mod, b.childs[0].copy_to(b)), lazyAccumulateExponent(a, 1, b);
                break
            }
            if (g.exp_node.is_integer_exact()) {
                b.remove_child_at(f), b.treat_as_constant = !0, b.type == pOPERATOR && b.token == "*" && b.childs.length == 1 && (b.childs[0].neg_mod = b.childs[0].neg_mod != b.neg_mod, b.childs[0].copy_to(b)), lazyAccumulateExponent(a, g.exp_node.token, b);
                break
            }
            d.error("This solver can't handle non-integral and non-constant powers of the variable to solve for.")
        }
    } else h = b.toString(), d.error("This solver can't handle variable expressions inside more complex constructs like function calls.")
}
var MAX_EXPONENT_UNROLL, pUNKNOWN = -1,
    pVARIABLE = 0,
    pOPERATOR = 1,
    pFUNCTION = 2,
    pCONSTANT = 3,
    pSTRINGS = {};
pSTRINGS[pUNKNOWN] = "unknown", pSTRINGS[pVARIABLE] = "variable", pSTRINGS[pOPERATOR] = "operator", pSTRINGS[pFUNCTION] = "function", pSTRINGS[pCONSTANT] = "constant", MAX_EXPONENT_UNROLL = 4, ExpNode.prototype.isSequenceOfFlatLists = function () {
    var a;
    if (this.type == pOPERATOR && this.token == "," && this.childs.length > 1) {
        for (a = 0; a < this.childs.length; a++) if (!this.childs[a].isFlatList()) return !1;
        return !0
    }
    return !1
}, ExpNode.prototype.containsList = function () {
    var a, b;
    for (a = 0; a < this.childs.length; a++) {
        b = this.childs[a];
        if (b.type == pFUNCTION && b.token == "\\list") return !0;
        if (b.containsList(b)) return !0
    }
    return !1
}, ExpNode.prototype.isFlatList = function () {
    return this.type == pFUNCTION && this.token == "\\list" && !this.containsList()
}, ExpNode.prototype.isPointList = function () {
    var a;
    if (this.isSequenceOfFlatLists()) {
        for (a = 0; a < this.childs.length; a++) if (this.childs[a].childs.length != 2) return !1;
        return !0
    }
    return this.isFlatList() ? this.childs.length == 2 : !1
}, ExpNode.prototype.is_integer_exact = function () {
    return this.type == pCONSTANT && this.token == Math.round(this.token)
}, ExpNode.prototype.is_value = function () {
    return this.type == pVARIABLE || this.type == pCONSTANT
}, ExpNode.prototype.for_each_child = function (a) {
    var b;
    for (b = 0; b < this.childs.length; b++) a(this.childs[b], b);
    this.exp_node != null && a(this.exp_node, null)
}, ExpNode.prototype.remove_child_at = function (a) {
    this.childs.splice(a, 1)
}, ExpNode.prototype.to_string = function (a) {
    var b, c, d = "";
    a != null && (d = a), b = d + "NODE " + pSTRINGS[this.type] + ": ", this.neg_mod && (b += "neg "), this.token == null ? b += "null" : b += this.token.toString(), this.exp_node && (b += "\r\n" + d + "  ^ \r\n" + this.exp_node.to_string(d + "    "));
    if (this.type != pCONSTANT && this.type != pVARIABLE) {
        b += "\r\n" + d + "{\r\n";
        for (c = 0; c < this.childs.length; c++) b += this.childs[c].to_string(d + "    ") + "\r\n";
        b += d + "}"
    }
    return b
}, ExpNode.prototype.toString = ExpNode.prototype.to_string, ExpNode.prototype.clone = function () {
    var a, b, c = new ExpNode(null, this.token, this.type);
    c.treat_as_constant = this.treat_as_constant, c.neg_mod = this.neg_mod;
    for (a = 0; a < this.childs.length; a++) b = this.childs[a].clone(), b.parent = c, c.childs.push(b);
    return this.exp_node != null && (c.exp_node = this.exp_node.clone()), c
}, ExpNode.prototype.copy_to = function (a) {
    var b, c;
    a.type = this.type, a.token = this.token, a.treat_as_constant = this.treat_as_constant, a.neg_mod = this.neg_mod, a.childs = [];
    for (b = 0; b < this.childs.length; b++) c = this.childs[b].clone(), c.parent = a, a.childs.push(c);
    a.exp_node = this.exp_node
}, ExpNode.prototype.references = function (a) {
    var b;
    if (this.type != pVARIABLE && this.type != pFUNCTION || !__is_in_list(a, this.token)) {
        for (b = 0; b < this.childs.length; b++) if (this.childs[b].references(varname)) return !0;
        return this.exp_node != null && this.exp_node.references(varname) ? !0 : !1
    }
    return !0
}, ExpNode.prototype.mark_constants = function (a) {
    var b, c = {};
    for (b = 0; b < a.length; b++) c[a[b]] = !0;
    this._mark_constants(c)
}, ExpNode.prototype._mark_constants = function (a) {
    var b, c, d;
    if (this.childs.length == 0) {
        this.exp_node != null && this.exp_node._mark_constants(a);
        if (this.type == pVARIABLE) this.treat_as_constant = !(this.token in a) && (this.exp_node == null || this.exp_node.treat_as_constant);
        else {
            if (this.type != pCONSTANT) throw {
                error: "Badly formed expression: leaf nodes of expressions must be variables or constants."
            };
            this.treat_as_constant = this.exp_node == null || this.exp_node.treat_as_constant
        }
    } else {
        b = !0;
        for (c = 0; c < this.childs.length; c++) d = this.childs[c], d._mark_constants(a), b = b && d.treat_as_constant;
        this.exp_node != null && (this.exp_node._mark_constants(a), b = b && this.exp_node.treat_as_constant), this.treat_as_constant = b
    }
}, ExpNode.prototype.canonical_form = function (a, b) {
    var c, d = {};
    for (c = 0; c < a.length; c++) d[a[c]] = !0;
    return this._zeroify(), this._mark_constants(d), this._r_canonical_form(d, b), b
}, ExpNode.prototype._zeroify = function () {
    var a;
    this.type == pOPERATOR && this.token in COMPARISON_OPS && (a = new ExpNode(this, "+", pOPERATOR), this.childs[0].parent = a, this.childs[1].parent = a, this.childs[1].neg_mod = !this.childs[1].neg_mod, a.childs = this.childs, this.childs = [a, new ExpNode(this, 0, pCONSTANT)])
}, WarningBuffer.prototype.has_warnings = function () {
    return this.warnings.length > 0
}, WarningBuffer.prototype.info = function (a) {
    this.infos.push(a)
}, WarningBuffer.prototype.warn = function (a) {
    this.warnings.push(a)
}, WarningBuffer.prototype.error = function (a) {
    throw this.errors.push(a), {
        error: a
    }
}, ExpNode.prototype._r_canonical_form = function (a, b) {
    var c, d = !0,
        e = 0;
    while (d) d = !1, d = this.flatten_negations(a, b) || d, d = this.gather_exponents(a, b) || d, c = this.toString(), d = this.flatten_multiplications(a, b) || d, c = this.toString(), d = this.flatten_additions(a, b) || d, c = this.toString(), d && this.flatten_negations(a, b), d = this.unroll_exponents(a, b) || d, c = this.toString(), d && (this.flatten_multiplications(a, b), this._mark_constants(a), this.flatten_negations(a, b)), d = this.distribute_multiplications(a, b) || d, c = this.toString(), d = this.compress_terms(a, b) || d, c = this.toString(), e++, e > 10 && b.error("Sorry, the solver can't figure this one out.")
}, ExpNode.prototype._solve_for = function (a, b) {
    var c, d, e = {};
    return e[a] = !0, this._mark_constants(e), this.collect_terms(a, b), this.flatten_negations(e, b), b.has_warnings() ? null : (c = this.toString(), d = this.extract_coefficients(a), ExpNode.MakeSolutions(a, d))
}, ExpNode.prototype.solve_for = function (a) {
    var b, c, d, e, f, g, h, i, j, k = new WarningBuffer,
        l = this.clone();
    l.canonical_form([a], k);
    if (k.warnings.length > 0) return {
        formulas: [],
        errors: k
    };
    b = l._solve_for(a, k);
    for (c = 0; c < b.length; c++) d = b[c], e = new ExpressionBuilder, f = [], g = [], h = [], i = e._r_analyze(d, f, g, h, !0, {}), j = new Formula(d), j.assignment = i.assignment, j.dependent = f, j.optional = h, j.alias = g, j.is_function = i.is_function, j.is_valid = !0, j.comparer = i.comparer, j.self_reference = i.self_reference, b[c] = j;
    return {
        formulas: b,
        errors: k
    }
}, ExpNode.prototype.flatten_negations = function (a, b) {
    var c, d, e, f = !1;
    return this.type == pOPERATOR && this.token == "-" && this.childs.length == 1 ? (c = this.childs[0], c.neg_mod && this.exp_node != null ? c.treat_as_constant || b.warn("Sorry, the solver can't handle negations nested inside exponents.") : (d = this.neg_mod == c.neg_mod, e = this.exp_node, c.exp_node != null && (this.exp_node != null ? (e = new ExpNode(null, "*", pOPERATOR), e.childs = [this.exp_node, c.exp_node]) : e = c.exp_node), c.copy_to(this), this.neg_mod = d, this.exp_node = e), f = !0) : this.type == pCONSTANT && this.neg_mod ? this.exp_node == null && (this.token = -this.token, this.neg_mod = !1) : this.for_each_child(function (c) {
        c.flatten_negations(a, b) && (f = !0)
    }), f
}, ExpNode.prototype.gather_exponents = function (a, b) {
    var c, d, e, f, g, h = !1;
    this.for_each_child(function (c) {
        c.gather_exponents(a, b) && (h = !0)
    });
    if (this.type == pOPERATOR && this.token == "^") {
        c = this.childs[0], d = this.childs[1];
        if (c.neg_mod) {
            if (!d.is_integer_exact()) return this.type = pOPERATOR, this.token = "-", this.exp_node = d, d.parent = null, c.neg_mod = !1, this.childs = [c], c.treat_as_constant || b.warn("The solver can't resolve expressions where a negated variable is raised to a non-integer exponent."), !0;
            this.neg_mod = this.neg_mod != (d.token % 2 != 0), c.neg_mod = !1, h = !0
        }
        c.neg_mod || (c.exp_node != null && (e = c.exp_node, e.type == pCONSTANT && d.type == pCONSTANT ? ((e.token < 0 || d.token < 0) && b.info("Negative exponents were automatically expanded out, but the solutions may be hiding divide by zero errors."), d.token = d.token * e.token, e.neg_mod && (d.token *= -1)) : (f = new ExpNode(null, "*", pOPERATOR), f.childs = [e, d], e.parent = f, d.parent = f, d = f, f.treat_as_constant = e.treat_as_constant && d.treat_as_constant, c.exp_node = null)), g = this.neg_mod, c.copy_to(this), this.exp_node = d, d.parent = null, this.neg_mod = g), h = !0
    }
    return h
}, ExpNode.prototype._r_m_descent = function (a, b, c) {
    var d, e, f, g, h, i, j, k = !1;
    this.neg_mod && (c.neg = !c.neg, this.neg_mod = !1, k = !0);
    if (this.exp_node != null && this.exp_node.type == pCONSTANT && (this.exp_node.token == -1 || this.exp_node.token == 1 && this.exp_node.neg_mod)) d = b, b = a, a = d, this.exp_node = null;
    else if (this.exp_node != null && this.childs.length > 0 && this.type == pOPERATOR && (this.token == "/" || this.token == "*")) {
        e = !0;
        for (f = 0; f < this.childs.length; f++) if (this.childs[f].neg_mod) {
            e = !1;
            break
        }
        if (e) {
            for (f = 0; f < this.childs.length; f++) g = this.childs[f], h = g.exp_node, g.exp_node == null ? g.exp_node = this.exp_node.clone() : (i = new ExpNode(null, "*", pOPERATOR), j = this.exp_node.clone(), j.parent = i, h.parent = i, i.childs = [j, h], g.exp_node = i);
            this.exp_node = null
        }
    }
    if (this.exp_node == null) if (this.type == pOPERATOR && this.token == "*") for (f = 0; f < this.childs.length; f++) g = this.childs[f], k = g._r_m_descent(a, b, c) || k;
    else this.type == pOPERATOR && this.token == "/" ? (k = !0, this.childs[0]._r_m_descent(a, b, c), this.childs[1]._r_m_descent(b, a, c)) : a.push(this);
    else a.push(this);
    return k
}, ExpNode.prototype.flatten_multiplications = function (a, b) {
    var c, d, e, f, g, h, i = !1;
    this.for_each_child(function (c) {
        c.flatten_multiplications(a, b) && (i = !0)
    }), c = [], d = [], e = {
        neg: this.neg_mod,
        pw: []
    };
    if (this.type == pOPERATOR && this.token == "*") for (f = 0; f < this.childs.length; f++) i = this.childs[f]._r_m_descent(c, d, e) || i;
    else {
        if (this.type != pOPERATOR || this.token != "/") return i;
        this.childs[1].treat_as_constant || b.info("The solver detected a variable in a fraction denominator - this solver cannot account for potential divide-by-zero errors."), i = this.childs[0]._r_m_descent(c, d, e) || i, i = this.childs[1]._r_m_descent(d, c, e) || i
    }
    g = new ExpNode(null, "*", pOPERATOR), g.treat_as_constant = !0;
    for (f = 0; f < c.length; f++) h = c[f], h.parent = g, g.treat_as_constant = g.treat_as_constant && h.treat_as_constant, g.childs.push(h);
    for (f = 0; f < d.length; f++) h = d[f], h.exp_node != null ? h.exp_node.neg_mod = !h.exp_node.neg_mod : h.exp_node = new ExpNode(null, -1, pCONSTANT), h.parent = g, g.treat_as_constant = g.treat_as_constant && h.treat_as_constant, g.childs.push(h);
    return g.childs.length == 1 ? g.childs[0].copy_to(g) : g.childs.length == 0 && (g = new ExpNode(null, 1, pCONSTANT)), g.neg_mod = e.neg, g.exp_node = this.exp_node, g.copy_to(this), i
}, ExpNode.prototype._r_a_descent = function (a, b) {
    var c, d = !1,
        e = !1;
    b === !0 && (e = !0), e = e != this.neg_mod;
    if (this.exp_node != null) this.neg_mod = e, a.push(this);
    else if (this.type == pOPERATOR && this.token == "+") {
        d = !0;
        for (c = 0; c < this.childs.length; c++) this.childs[c]._r_a_descent(a, e)
    } else this.type == pOPERATOR && this.token == "-" ? (d = !0, this.childs.length == 1 ? this.childs[0]._r_a_descent(a, !e) : (this.childs[0]._r_a_decsent(a, e), this.childs[1]._r_a_decsent(a, !e))) : (this.neg_mod = e, a.push(this));
    return d
}, ExpNode.prototype.flatten_additions = function (a, b) {
    var c, d, e = !1;
    this.for_each_child(function (c) {
        c.flatten_additions(a, b) && (e = !0)
    }), this.type == pOPERATOR && this.token == "-" && (this.token = "+", this.childs.length == 1 ? (this.childs[0].neg_mod = !this.childs[0].neg_mod, e = !0) : (this.childs[1].neg_mod = !this.childs[1].neg_mod, e = !0));
    if (this.type == pOPERATOR && this.token == "+") {
        c = [];
        for (d = 0; d < this.childs.length; d++) e = this.childs[d]._r_a_descent(c, !1) || e;
        this.treat_as_constant = !0;
        for (d = 0; d < c.length; d++) c[d].parent = this, this.treat_as_constant = this.treat_as_constant && c[d].treat_as_constant;
        this.childs = c
    }
    return e
}, ExpNode.prototype._unroll_exponents = function (a, b) {
    var c, d, e, f, g, h = !1;
    this.exp_node.token < 0 && (this.exp_node.token = -this.exp_node.token, c = this.clone(), c.parent = this, d = new ExpNode(this, 1, pCONSTANT), this.type = pOPERATOR, this.token = "/", this.childs = [d, c], this.flatten_multiplications(a, b), this.flatten_negations(a, b), h = !0);
    if (this.exp_node.token == 0) this.type = pCONSTANT, this.token = 1, this.childs = [], this.treat_as_constant = !0, this.exp_node = null, h = !0;
    else if (this.exp_node.token == 1) this.exp_node = null, h = !0;
    else if (this.type == pOPERATOR) {
        e = this.exp_node.token, this.exp_node = null, c = this.clone(), c.neg_mod = !1, this.type = pOPERATOR, this.childs = [], this.token = "*";
        for (f = 0; f < e; f++) g = c.clone(), g.parent = this, this.childs.push(g);
        h = !0
    }
    return h
}, ExpNode.prototype.unroll_exponents = function (a, b) {
    var c = !1;
    return this.for_each_child(function (d) {
        d.unroll_exponents(a, b) && (c = !0)
    }), !this.treat_as_constant && this.exp_node != null && (this.exp_node.is_integer_exact() && this.exp_node.token >= -MAX_EXPONENT_UNROLL && this.exp_node.token <= MAX_EXPONENT_UNROLL ? this.type != pOPERATOR || this.token != "/" && this.token != "*" && this.token != "+" ? this.type != pVARIABLE && (this.type == pOPERATOR && this.token == "-" ? b.warn("This solver can't handle fractional powers in the (-x)^n style.") : b.warn("The solver ran into an operator or function that it doesn't support.")) : c = this._unroll_exponents(a, b) || c : b.warn("This solver can't handle variable parenthesized expressions that are raised to non-constant powers or powers higher than " + MAX_EXPONENT_UNROLL.toString() + ".")), c
}, ExpNode.prototype._r_distribute = function (a, b, c, d, e) {
    var f, g, h = this.childs[d];
    if (d == this.childs.length - 1) if (h.type != pOPERATOR || h.token != "+" || !! h.exp_node && h.exp_node.token !== 1) c.push(prefixCopy(e, h));
    else for (f = 0; f < h.childs.length; f++) c.push(prefixCopy(e, h.childs[f]));
    else if (h.type != pOPERATOR || h.token != "+" || !! h.exp_node && h.exp_node.token !== 1) e.push(h), this._r_distribute(a, b, c, d + 1, e), e.pop();
    else for (f = 0; f < h.childs.length; f++) g = h.childs[f], e.push(g), this._r_distribute(a, b, c, d + 1, e), e.pop()
}, ExpNode.prototype._distribute = function (a, b) {
    var c, d, e, f, g, h, i = [];
    this._r_distribute(a, b, i, 0, []), this.childs = [], this.type = pOPERATOR, this.token = "+";
    for (c = 0; c < i.length; c++) {
        d = !0, e = i[c], f = new ExpNode(this, "*", pOPERATOR);
        for (g = 0; g < e.length; g++) h = e[g], h.parent = f, f.childs.push(h), h.treat_as_constant || (d = !1);
        f.treat_as_constant = d, this.childs.push(f)
    }
}, ExpNode.prototype.distribute_multiplications = function (a, b) {
    var c, d, e, f = !1;
    this.for_each_child(function (c) {
        c.distribute_multiplications(a, b) && (f = !0)
    });
    if (!this.treat_as_constant && this.type == pOPERATOR && this.token == "*") {
        c = !1;
        for (d = 0; d < this.childs.length; d++) {
            e = this.childs[d];
            if (!e.treat_as_constant && e.type == pOPERATOR && e.token == "+") {
                c = !0;
                break
            }
        }
        f = c, c && this._distribute(a, b)
    }
    return f
}, ExpNode.prototype._r_extract_terms = function (a, b, c, d, e, f) {
    var g, h = !1;
    if (!this.treat_as_constant && this.type == pOPERATOR && this.token == "*") {
        this.neg_mod && (f.negmod = !f.negmod);
        for (g = 0; g < this.childs.length; g++) this.childs[g]._r_extract_terms(a, b, c, d, e, f)
    } else!this.treat_as_constant && this.type == pOPERATOR && this.token == "/" ? (this.neg_mod && (f.negmod = !f.negmod), this.childs[0]._r_extract_terms(a, b, c, d, e, f), this.childs[1]._r_extract_terms(a, b, c, d, !e, f)) : !this.treat_as_constant && this.type == pVARIABLE ? (this.neg_mod && (f.negmod = !f.negmod), this.exp_node != null ? this.exp_node.type == pCONSTANT ? h = lazyAdd(c, this.token, this.exp_node.token, e != this.exp_node.neg_mod) || h : (this.exp_node != null && e ? this.exp_node.neg_mod = !this.exp_node.neg_mod : e && (this.exp_node = new ExpNode(null, -1, pCONSTANT)), d.push(this), b.warn("The solver doesn't support non-integer exponents of expressions containing unknown variables.")) : h = lazyAdd(c, this.token, 1, e) || h) : this.type == pOPERATOR && (this.token == "+" || this.token == "-" || this.token == "*" || this.token == "/") || this.type == pCONSTANT || this.type == pVARIABLE || this.treat_as_constant ? (this.exp_node != null && e ? this.exp_node.neg_mod = !this.exp_node.neg_mod : e && (this.exp_node = new ExpNode(null, -1, pCONSTANT)), d.push(this)) : (this.exp_node != null && e ? this.exp_node.neg_mod = !this.exp_node.neg_mod : e && (this.exp_node = new ExpNode(null, -1, pCONSTANT)), d.push(this), b.warn("The solver can't support non-arithmetic variable expressions, although constant ones will work."));
    return h
}, ExpNode.prototype._r_compress_reconstruct = function (a, b, c) {
    var d, e, f, g = !0;
    this.childs = [];
    for (d in a) a[d] != 0 && (e = new ExpNode(this, d, pVARIABLE), a[d] != 1 && (e.exp_node = new ExpNode(e, a[d], pCONSTANT)), this.childs.push(e), g = !1);
    for (f = 0; f < b.length; f++) e = b[f], e.parent = this, this.childs.push(e);
    this.childs.length == 1 ? this.token = "+" : this.token = "*", c.negmod && (this.neg_mod = !this.neg_mod), this.treat_as_constant = g
}, ExpNode.prototype.compress_terms = function (a, b) {
    var c, d, e, f, g = !1;
    this.for_each_child(function (c) {
        c.compress_terms(a, b) && (g = !0)
    }), c = {}, d = {
        negmod: !1
    }, e = [];
    if (this.type == pOPERATOR && this.token == "*") {
        for (f = 0; f < this.childs.length; f++) g = this.childs[f]._r_extract_terms(a, b, c, e, !1, d) || g;
        this._r_compress_reconstruct(c, e, d)
    } else this.type == pOPERATOR && this.token == "/" ? (g = this.childs[0]._r_extract_terms(a, b, c, e, !1, d) || g, g = this.childs[1]._r_extract_terms(a, b, c, e, !0, d) || g, this._r_compress_reconstruct(c, e, d)) : !this.treat_as_constant && (this.type != pOPERATOR && this.type != pCONSTANT && this.type != pVARIABLE || this.type == pOPERATOR && this.token != "+" && this.token != "-" && this.token != "*" && this.token != "/" && this.token != "=") && b.warn("The solver can't support non-arithmetic variable expressions, although constant ones will work.");
    return g
}, ExpNode.prototype.collect_terms = function (a, b) {
    var c, d, e, f, g, h, i, j, k, l;
    this.for_each_child(function (c) {
        c.collect_terms(a, b)
    });
    if (!this.treat_as_constant && this.type == pOPERATOR && this.token == "+") {
        c = {};
        for (d = 0; d < this.childs.length; d++) e = this.childs[d], accumulateExponent(c, e, a, b);
        this.childs = [], this.treat_as_constant = !0;
        for (f in c) if (f == 0) {
            g = c[f];
            if (g.length == 1) h = g[0], h.parent = this, h.treat_as_constant = !0, this.childs.push(h);
            else {
                i = new ExpNode(this, "+", pOPERATOR);
                for (j = 0; j < g.length; j++) g[j].parent = i, i.childs.push(g[j]);
                i.treat_as_constant = !0, this.childs.push(i)
            }
        } else {
            this.treat_as_constant = !1, g = c[f];
            if (g.length == 1) i = new ExpNode(this, "*", pOPERATOR), k = new ExpNode(i, a, pVARIABLE), f != 1 && (k.exp_node = new ExpNode(null, f, pCONSTANT)), l = g[0], l.parent = i, i.treat_as_constant = !1, k.treat_as_constant = !1, l.treat_as_constant = !0, i.childs = [k, l], this.childs.push(i);
            else {
                i = new ExpNode(this, "*", pOPERATOR), k = new ExpNode(i, a, pVARIABLE), f != 1 && (k.exp_node = new ExpNode(null, f, pCONSTANT)), l = new ExpNode(i, "+", pOPERATOR);
                for (j = 0; j < g.length; j++) g[j].parent = i, l.childs.push(g[j]);
                k.treat_as_constant = !1, i.treat_as_constant = !1, l.treat_as_constant = !0, i.childs = [k, l], this.childs.push(i)
            }
        }
    }
}, ExpNode.MakeSolutions = function (a, b) {
    var c, d, e, f = new ExpNode(null, "=", pOPERATOR),
        g = new ExpNode(f, a, pVARIABLE),
        h = new ExpNode(f, "\\solvequadratic1", pFUNCTION),
        i = new ExpNode(h, 0, pCONSTANT),
        j = new ExpNode(h, 0, pCONSTANT),
        k = new ExpNode(h, 0, pCONSTANT);
    f.childs = [g, h], 2 in b && (i = b[2], i.parent = h), 1 in b && (j = b[1], j.parent = h), 0 in b && (k = b[0], k.parent = h), h.childs = [i, j, k];
    if (2 in b) return c = new ExpNode(null, "=", pOPERATOR), d = new ExpNode(c, a, pVARIABLE), e = h.clone(), e.token = "\\solvequadratic2", c.childs = [d, e], [f, c];
    if (1 in b) return [f];
    throw {
        error: "Error: variable cancels itself out."
    }
}, ExpNode.prototype._r_hasLoopOperator = function () {
    var a;
    if (this.type == pOPERATOR && this.token in {
        "\\sum": !0,
        "\\int": !0
    }) return !0;
    for (a = 0; a < this.childs.length; a++) if (this.childs[a]._r_hasLoopOperator()) return !0;
    return !1
}, ExpNode.prototype.extract_coefficients = function (a) {
    var b, c, d, e, f, g;
    if (this.type == pOPERATOR && this.token in COMPARISON_OPS) {
        b = !1, c = null;
        for (d = 0; d < this.childs.length; d++) {
            e = this.childs[d];
            if (e.type != pCONSTANT || e.token != 0) {
                b = !0, c = e;
                break
            }
        }
        return b ? c.extract_coefficients(a) : null
    }
    if (this.type == pOPERATOR && this.token == "+") {
        f = {};
        for (d = 0; d < this.childs.length; d++) {
            e = this.childs[d];
            if (e.treat_as_constant) f[0] = e;
            else if (e.type == pOPERATOR && e.token == "*") {
                g = e.childs[0];
                if (g.type != pVARIABLE || g.token != a) throw {
                    error: "Sorry, the solver can't deal with multivariable equations."
                };
                if (g.exp_node == null) f[1] = e.childs[1];
                else {
                    if (!g.exp_node.is_integer_exact() || g.exp_node.token != 2) throw {
                        error: "Sorry, the solver can only solve arithmetic, up to quadratic expressions."
                    };
                    f[g.exp_node.token] = e.childs[1]
                }
            } else {
                if (e.type != pVARIABLE || e.token != a) throw {
                    error: "Sorry, the solver can only solve arithmetic expressions."
                };
                if (e.exp_node == null) f[1] = new ExpNode(null, 1, pCONSTANT);
                else {
                    if (!e.exp_node.is_integer_exact() || e.exp_node.token != 1 && e.exp_node.token != 2) throw {
                        error: "Sorry, the solver can't deal with non-integer, non-quadratic exponents."
                    };
                    f[1] = new ExpNode(null, e.exp_node.token, pCONSTANT)
                }
            }
        }
        return f
    }
}, ExpNode.prototype.deconvert_implicit_multiplications = function (a) {
    var b, c, d;
    for (b = 0; b < this.childs.length; b++) this.childs[b].deconvert_implicit_multiplications(a);
    if (this.type == pFUNCTION) {
        c = a.get_local(this.token);
        if (c == null || c.type != ENV_USER_DEFINED && c.type != ENV_INTRINSIC) d = new ExpNode(this, this.token, this.type), this.copy_to(d), d.childs = [], d.parent = this, d.type = pVARIABLE, this.childs.push(d), this.neg_mod = !1, this.exp_node = null, this.type = pOPERATOR, this.token = "*"
    }
};;

function Formula(a) {
    return this.latex = "", this.expression = a, this.solver_expression = null, this.dependent = [], this.assignment = null, this.is_function = !1, this.error = "", this.alias_map = null, this.is_valid = !1, this.variables = [], this.alias = [], this.optional = [], this.zero_value = NaN, this.domain = {
        min: -1,
        max: 1
    }, this.comparer = null, this.self_reference = !1, this.subformulas = null, this
}
var GRAPHMODE_Y = 0,
    GRAPHMODE_X = 1,
    GRAPHMODE_POLAR = 2,
    GRAPHMODE_XYPOINT = 3,
    GRAPHMODE_PARAMETRIC = 5;
Formula.constFormula = function (a, b) {
    var c, d = new ExpNode(null, "=", pOPERATOR),
        e = new ExpNode(d, a, pVARIABLE),
        f = new ExpNode(d, b, pCONSTANT);
    return d.childs = [e, f], c = new Formula(d), c.assignment = a, c.is_valid = !0, c.comparer = "=", c
}, Formula.prototype.isPointList = function () {
    return this.expression != null && this.expression.isPointList() && (this.variables.length != 1 || this.variables[0].toLowerCase() != "t")
}, Formula.prototype.isSequenceOfLists = function () {
    return this.expression != null && (this.expression.isSequenceOfFlatLists() || this.expression.isFlatList())
}, Formula.prototype.toString = function () {
    var a = "FORMULA\r\n";
    return this.is_function && (a += "FUNCTION\r\n"), this.assignment != null ? a += "Assigned: " + this.assignment.toString() + "\r\n" : a += "Assigned: not defined\r\n", a += "Aliases: " + Formula.listToString(this.alias) + "\r\n", a += "Dependent on: " + Formula.listToString(this.dependent) + "\r\n", a += "Variables: " + Formula.listToString(this.variables) + "\r\n", a += "Latex: |" + this.latex + "| \r\n", a += this.expression ? this.expression.toString() : null, a
}, Formula.prototype.get_alias_index = function (a) {
    var b;
    if (this.alias_map == null) {
        this.alias_map = {};
        for (b = 0; b < this.alias.length; b++) this.alias_map[this.alias[b]] = b
    }
    return a in this.alias_map ? this.alias_map[a] : null
}, Formula.prototype.get_rvalue = function () {
    return this.assignment != null && this.comparer != null ? this.expression.childs[1] : this.expression
}, Formula.prototype.is_definition = function () {
    return this.assignment != null
}, Formula.prototype.get_operator = function () {
    var a = this.expression;
    if (!a) return "";
    if (this.expression.type == pOPERATOR) switch (this.expression.token) {
    case "=":
    case ">=":
    case "<=":
    case ">":
    case "<":
        return this.expression.token;
    case "\\le":
        return "<=";
    case "\\ge":
        return ">="
    }
    return ""
}, Formula.prototype.has_comparer = function () {
    return this.comparer != null
}, Formula.listToString = function (a) {
    return a == null ? "null" : a.length <= 0 ? "[]" : "[" + a.toString() + "]"
}, Formula.prototype.is_equation = function () {
    var a = this.expression;
    return a.type == pOPERATOR && a.token == "="
}, Formula.prototype.is_assignable = function () {
    return f = this, !f.is_self_referencing && f.is_definition() && f.get_operator() == "=" && f.assignment != "y" && f.assignment != "x" && f.assignment != "Y" && f.assignment != "X" && f.assignment != "r" && f.assignment != "R" && f.assignment != "\\theta" && f.assignment != "theta"
}, Formula.prototype.graph_mode = function () {
    return this.isPointList() ? GRAPHMODE_XYPOINT : this.is_yequals() ? GRAPHMODE_Y : this.is_xequals() ? GRAPHMODE_X : this.is_requals() ? GRAPHMODE_POLAR : this.is_parametric() ? GRAPHMODE_PARAMETRIC : GRAPHMODE_Y
}, Formula.prototype.is_graphable = function () {
    var a = this.getFormulas()[0];
    return this.latex == "" || a.containsError() ? !1 : this.latex.split("\\space").join(" ").split(" ").join("").toLowerCase() == "x" ? !1 : a.alias.length == 0 && a.assignment && a.assignment.toLowerCase() in {
        y: !0,
        x: !0,
        r: !0
    } && a.variables.length <= 1 ? !0 : a.assignment && a.get_operator() != "=" ? !0 : a.assignment && a.alias.length == 1 && a.alias[0].toLowerCase() == "x" && a.variables.length == 0 ? !0 : a.alias.length == 0 && a.variables.length == 1 && a.variables[0].toLowerCase() == "x" ? !0 : a.assignment && a.alias.length == 1 && a.alias[0].toLowerCase() == "y" && a.variables.length == 0 ? !0 : a.assignment && a.alias.length == 0 && a.variables.length == 1 && a.variables[0].toLowerCase() == "y" ? !0 : a.assignment && a.alias.length > 0 && a.alias.length == 1 && a.alias[0] == "\\theta" && a.variables.length == 0 ? !0 : a.assignment && a.alias.length == 0 && a.variables.length == 1 && a.variables[0] == "\\theta" ? !0 : a.alias.length == 1 ? !0 : a.isPointList() || a.is_parametric() ? !0 : !1
}, Formula.prototype.is_slidable = function () {
    var a = this;
    return a.getFormulas().length > 1 || a.getFormulas()[0] != a ? !1 : a.containsError() ? !1 : !a.assignment || a.assignment.toLowerCase() in {
        y: !0,
        x: !0,
        r: !0
    } ? !1 : a.get_operator() != "=" ? !1 : a.alias.length > 0 ? !1 : isNaN(a.getSimpleConstant()) ? !1 : !0
}, Formula.prototype.is_yequals = function () {
    var a = this;
    return a.assignment == null && (a.variables.length == 0 || a.variables.length == 1 && a.variables[0].toLowerCase() == "x") || a.assignment && a.assignment.toLowerCase() == "y"
}, Formula.prototype.is_xequals = function () {
    var a = this;
    return a.assignment == null && a.variables.length == 1 && a.variables[0].toLowerCase() == "y" || a.assignment && a.assignment.toLowerCase() == "x"
}, Formula.prototype.is_requals = function () {
    var a = this;
    return a.assignment == "r" || a.assignment == "R"
}, Formula.prototype.is_parametric = function () {
    return this.expression != null && this.expression.isPointList() && this.variables.length == 1 && this.variables[0].toLowerCase() == "t"
}, Formula.fromLatex = function (a) {
    var b;
    try {
        b = parseLatex(a, !1)
    } catch (c) {
        b = new Formula(null), b.error = c.error
    }
    return b.latex = a, b
}, Formula.prototype.containsError = function () {
    return this.getError() ? !0 : !1
}, Formula.prototype.getError = function () {
    var a, b = this.getFormulas();
    for (a = 0; a < b.length; a++) if (b[a].error) return b[a].error;
    return ""
}, Formula.prototype.getFormulas = function () {
    return this.subformulas ? this.subformulas : [this]
}, Formula.prototype.getZeroValues = function () {
    var a, b, c = [],
        d = this.getFormulas();
    for (b = 0; b < d.length; b++) if (!isNaN(a = d[b].zero_value) && a != null) {
        if (a == Infinity || a == -Infinity) a = NaN;
        c.push({
            val: a,
            operator: d[b].get_operator()
        })
    } else isNaN(a) && c.push({
        val: NaN,
        operator: d[b].get_operator()
    });
    return c.sort(function (a, b) {
        return (a.val > b.val) - (a.val < b.val)
    }), c
}, Formula.prototype.getAssignment = function () {
    var a, b = "",
        c = this.getFormulas();
    if (!c.length) return "";
    b = c[0].assignment;
    for (a = 1; a < c.length; a++) if (c[a].assignment != b) return "";
    return b
}, Formula.prototype.getVariables = function () {
    return this.subformulas && this.subformulas.length ? this.subformulas[0].variables : this.variables
}, Formula.prototype.hasLoopOperator = function () {
    return this.expression._r_hasLoopOperator()
}, Formula.prototype.getSimpleConstant = function () {
    var a = this.get_rvalue();
    return a ? a.type == pCONSTANT ? a.token * (a.neg_mod ? -1 : 1) : NaN : NaN
}, Formula.prototype.isImplicitConstant = function () {
    var a, b;
    if (this.subformulas == null) return !1;
    for (a = 0; a < this.subformulas.length; a++) {
        b = this.subformulas[a];
        if (b.expression.type != pCONSTANT) return !1
    }
}, Formula.prototype.deconvert_implicit_multiplications = function (a) {
    var b;
    this.solver_expression = this.expression.clone(), this.solver_expression.deconvert_implicit_multiplications(a);
    if (this.assignment != null && this.alias.length > 0) if (this.solver_expression.childs[0].type == pOPERATOR && this.solver_expression.childs[0].token == "*") {
        for (b = 0; b < this.alias.length; b++) this.dependent.push(this.alias[b]);
        this.alias = [], this.dependent.push(this.assignment), this.assignment = null
    } else if (this.solver_expression.childs[0].type == pFUNCTION && a.get_intrinsic(this.solver_expression.childs[0].token) != null) {
        for (b = 0; b < this.alias.length; b++) this.dependent.push(this.alias[b]);
        this.alias = [], this.dependent.push(this.assignment), this.assignment = null
    }
};;

function string_trim(a) {
    return a.replace(/^\s+|\s+$/g, "")
}
function wrap_exponents_in_braces(a) {
    var b = new RegExp("\\^([^{])", "gi");
    return a.replace(b, "^{$1}")
}
function parseLatex(a, b) {
    var c, d, e, f, g, h;
    a = string_trim(a), a = wrap_exponents_in_braces(a), c = [];
    while (a.length > 0) {
        d = a.search(TOKEN_RE);
        if (d != 0) {
            if (d > 0) {
                e = a.substring(0, d).replace(/^\\/, "");
                if (e.length > 0) throw {
                    error: "Unrecognized symbol: '" + e + "'"
                };
                c = [];
                break
            }
            e = a.substring(0).replace(/^\\/, "");
            if (e.length > 0) throw {
                error: "Unrecognized symbol: 'NaN"
            };
            c = [];
            break
        }
        f = a.match(TOKEN_RE)[0], c.push(f), a = string_trim(a.substr(f.length))
    }
    c = reprocessTokens(c);
    for (g = 0; g < c.length; g++) c[g] == "\\cdot" && (c[g] = "*");
    return h = (new ExpressionBuilder).parse(c, b), h
}
function reprocessTokens(a) {
    var b, c, d, e, f, g, h, i, j, k = [],
        l = 0;
    while (l < a.length) {
        b = a[l], b == "\\{" ? b = "{" : b == "\\}" && (b = "}");
        if (l < a.length - 1 && b.match(/^\\/i) === null && a[l + 1] == "_") {
            c = "", l += 2;
            if (l >= a.length) throw {
                error: "expected parameter following '_' subscript."
            };
            if (a[l] == "{") {
                c += "_{", l++, d = 1;
                while (l < a.length && d > 0) c += a[l], a[l] == "{" ? (d++, l++) : a[l] == "}" ? d-- : l++;
                if (d != 0) throw {
                    error: "expected } to terminate subscript."
                }
            } else c += "_" + a[l];
            k.push(b + c)
        } else if (l < a.length - 1 && b == "\\log" && a[l + 1] == "_") {
            l += 2;
            if (l >= a.length) throw {
                error: "expected parameter following '_' subscript."
            };
            e = [];
            if (a[l] == "{") {
                e.push("{"), l++, d = 1;
                while (l < a.length && d > 0) e.push(a[l]), a[l] == "{" ? (d++, l++) : a[l] == "}" ? d-- : l++;
                if (d != 0) throw {
                    error: "expected } to terminate subscript."
                }
            } else e.push(a[l]);
            k.push("\\left(");
            for (f = 0; f < e.length; f++) k.push(e[f]);
            k.push("\\right)"), k.push("\\hpm"), k.push("\\log")
        } else if (l < a.length - 1 && b == "\\sqrt" && a[l + 1] == "[") {
            g = [], h = [], l += 2, d = 1;
            while (l < a.length && d > 0) h.push(a[l]), a[l] == "[" && d++, a[l] == "]" && d--, l++;
            h.pop();
            if (h.length === 0) throw {
                error: "please enter the degree of the root (for example, '3' for a cube root)"
            };
            if (d != 0) throw {
                error: "expected ] to terminate root."
            };
            if (a[l] != "{") throw {
                error: "expected { to follow ] in nthroot"
            };
            l++, d = 1;
            while (l < a.length && d > 0) g.push(a[l]), a[l] == "{" && d++, a[l] == "}" && d--, l++;
            g.pop(), l--;
            if (d != 0) throw {
                error: "expected } to terminate root argument."
            };
            h = reprocessTokens(h), g = reprocessTokens(g), k.push("\\left(");
            for (f = 0; f < g.length; f++) k.push(g[f]);
            k.push("\\right)"), k.push("^"), k.push("{"), k.push("\\frac"), k.push("{"), k.push("1"), k.push("}"), k.push("{");
            for (f = 0; f < h.length; f++) k.push(h[f]);
            k.push("}"), k.push("}")
        } else if (b == "\\text") {
            l++;
            if (l >= a.length || a[l] != "{") throw {
                error: "expected { following \\text token."
            };
            l++, c = "\\";
            while (l < a.length && a[l] != "}") c += a[l], l++;
            if (l == a.length) throw {
                error: "expected } to terminate \\text token."
            };
            k.push(c)
        } else b in SYNTAX_SUBSTITUTIONS ? k.push(SYNTAX_SUBSTITUTIONS[b]) : b != "\\space" && b != "\\backslash" && k.push(b);
        l++
    }
    a = k, i = [];
    if (a.length == 0) return i;
    for (f = 0; f < a.length; f++) j = null, i.length > 0 && (j = i[i.length - 1]), b = a[f], b == "{" && j == "\\left" ? (i.pop(), i.push("\\left("), i.push("\\conditional"), i.push("\\left{")) : b == "}" && j == "\\right" ? (i.pop(), i.push("\\right}"), i.push("\\right)")) : b == "\\left[" ? (i.push("\\left("), i.push("\\list"), i.push("\\left[")) : b == "\\right]" ? (i.push("\\right]"), i.push("\\right)")) : j == "^" || j == "_" ? b.length > 1 && b != "{" ? (i.push(b.substr(0, 1)), i.push(b.substr(1))) : i.push(b) : i.push(b);
    return i
}
function TokenNode(a, b) {
    return this.parent = a, b != null ? this.tokens = b : this.tokens = [], this
}
function ExpressionBuilder() {
    return this.root = null, this.exp = null, this.assignment = null, this.is_function_definition = !1, this.dependent = [], this.aliases = [], this.optional = [], this.comparer = null, this.self_reference = !1, this
}
function hasCommonElement(a, b) {
    var c, d, e = {};
    for (c = 0; c < a.length; c++) d = a[c], e[d] = !0;
    for (c = 0; c < b.length; c++) {
        d = b[c];
        if (e[d]) return !0
    }
    return !1
}
var TOKEN_RE = /(\\left(\{|\(|\[|\|))|(\\right(\}|\)|\]|\|))|(\\[a-z]+)|(\#[a-z]+)|[a-z]|(([\d]*\.)?[\d]+)|\\le|\>|\\ge|\<|\=|\^|\_|\{|\}|\[|\]|\\\{|\\\}|\*|\-|\/|\+|\!|\,|\\space|\:|\\and|\\or|\\not|\\hpm|\\hpa|\\hpd/i,
    SYNTAX_SUBSTITUTIONS = {
        "\\ge": ">=",
        "\\le": "<=",
        "\\wedge": "\\and",
        "\\vee": "\\or",
        "\\neg": "\\not"
    },
    CONSTANT_RE = /^(([\d]*\.)?[\d]+)$/,
    VARIABLE_RE = /^(((\\[a-z]+)|(\#[a-z]+)|[a-z]+)(\_|\{|[0-9]|((\\[a-z]+)|(\#[a-z]+)|[a-z]+)|\})*)$/i,
    OPERATOR_RE = /^(\>\=|\>|\<\=|\<|\=|\^|\_|\*|\-|\/|\+|\!|\\cdot|\,|\~|\:|\\and|\\or|\\not|\\hpm|\\hpa|\\hpd)$/,
    FUNCTION_RE = /^(\\[a-z_]+(\_|\{|((\\[a-z]+)|(\#[a-z]+)|[a-z]+)|\})*)$/i,
    LEFT_PAREN_RE = /^(\\left(\{|\(|\[|\|))$/,
    RIGHT_PAREN_RE = /^(\\right(\}|\)|\]|\|))$/,
    LEFT_SEQ_RE = /^\{$/,
    RIGHT_SEQ_RE = /^\}$/,
    BRACKET_MAPPINGS = {
        "\\left(": null,
        "\\left[": null,
        "\\left{": null,
        "\\left|": null,
        "\\right)": "\\left(",
        "\\right]": "\\left[",
        "\\right}": "\\left{",
        "\\right|": "\\left|",
        "{": null,
        "}": "{"
    },
    OP_PRIORITIES = {
        ",": -4,
        ":": -3,
        "\\and": -2,
        "\\or": -2,
        "\\not": -2,
        ">=": -1,
        ">": -1,
        "<": -1,
        "<=": -1,
        "=": -1,
        "\\le": -1,
        "\\ge": -1,
        "+": 0,
        "-": 0,
        "*": 1,
        "/": 1,
        "!": 2,
        "^": 10,
        "\\hpm": 20,
        "\\hpa": 3,
        "\\hpd": 4,
        finish: -999,
        "~": 0
    },
    COMPARISON_OPS = {
        "=": !0,
        "<=": !0,
        "\\le": !0,
        "<": !0,
        ">=": !0,
        "\\ge": !0,
        ">": !0
    },
    INEQUALITY_OPS = {
        "<=": !0,
        "\\le": !0,
        "<": !0,
        ">=": !0,
        "\\ge": !0,
        ">": !0
    },
    INEQUALITY_FLIPS = {
        "<=": "\\ge",
        "\\le": "\\ge",
        "<": ">",
        ">=": "\\le",
        "\\ge": "\\le",
        ">": "<"
    },
    ALLOW_EXPONENTIAL_DECORATOR = {
        "\\sin": "\\arcsin",
        "\\sec": "\\arcsec",
        "\\csc": "\\arccsc",
        "\\cot": "\\arccot",
        "\\cos": "\\arccos",
        "\\tan": "\\arctan"
    },
    IMPLICIT_INVERSES = {
        "\\sin": "\\arcsin",
        "\\sec": "\\arcsec",
        "\\csc": "\\arccsc",
        "\\cot": "\\arccot",
        "\\cos": "\\arccos",
        "\\tan": "\\arctan",
        "\\sinh": "\\arcsinh",
        "\\cosh": "\\arccosh",
        "\\tanh": "\\arctanh"
    },
    FUNCTION_NAME_EXCEPTIONS = {
        "\\pi": !0
    };
TokenNode.prototype.print_view = function () {
    var a, b, c = [];
    for (a = 0; a < this.tokens.length; a++) b = this.tokens[a], b.nested ? c.push(b.value.print_view()) : c.push(b.value);
    return "[" + c.join(", ") + "]"
}, ExpressionBuilder.prototype.get_first_pass = function () {
    return this.root == null ? "null" : this.root.print_view()
}, ExpressionBuilder.prototype.parse = function (a, b) {
    var c, d, e = "",
        f = !0;
    if (!b) try {
        try {
            this.root = this._r_parse(null, a, 0, a.length), this.exp = this._r_make_tree(this.root)
        } catch (g) {
            try {
                e = g.error, this.exp = this.recovery_parse(a), f = !1
            } catch (h) {
                throw this.root = null, this.exp = null, g
            }
        }
        this.dependent = [], this.aliases = [], c = this._r_analyze(this.exp, this.dependent, this.aliases, this.optional, !0, {}), this.is_function_definition = c.is_function, this.assignment = c.assignment, this.comparer = c.comparer, this.self_reference = c.self_reference
    } catch (i) {
        this.root = null, this.exp = null, e = i.error
    } else {
        try {
            this.root = this._r_parse(null, a, 0, a.length), this.exp = this._r_make_tree(this.root)
        } catch (g) {
            try {
                e = g.error, this.exp = this.recovery_parse(a), f = !1
            } catch (h) {
                throw this.root = null, this.exp = null, g
            }
        }
        this.dependent = [], this.aliases = [], c = this._r_analyze(this.exp, this.dependent, this.aliases, this.optional, !0, {}), this.is_function_definition = c.is_function, this.assignment = c.assignment, this.comparer = c.comparer, this.self_reference = c.self_reference
    }
    return d = new Formula(this.exp), d.assignment = this.assignment, d.dependent = this.dependent, d.optional = this.optional, d.alias = this.aliases, d.is_function = this.is_function_definition, d.is_valid = f, d.error = e, d.comparer = this.comparer, d.self_reference = this.self_reference, d
}, ExpressionBuilder.prototype._find_matching_paren = function (a, b) {
    var c, d, e, f = [],
        g = 0;
    do {
        if (b + g >= a.length) throw {
            error: "could not find matching parentheses."
        };
        c = a[b + g];
        if (c in BRACKET_MAPPINGS) {
            d = BRACKET_MAPPINGS[c];
            if (d == null) f.push(c);
            else {
                e = f.pop();
                if (e != d) throw {
                    error: "mismatched parentheses"
                }
            }
        }
        g++
    } while (f.length > 0);
    return g - 1
}, ExpressionBuilder.prototype._r_parse = function (a, b, c, d) {
    var e, f, g, h, i, j = new TokenNode(a);
    for (e = 0; e < d; e++) f = c + e, g = b[f], g.match(LEFT_PAREN_RE) || g.match(LEFT_SEQ_RE) ? (h = this._find_matching_paren(b, f), i = this._r_parse(j, b, f + 1, h - 1), g == "\\left|" ? j.tokens.push({
        nested: !0,
        value: i,
        processed: !1,
        subexp: !0,
        absmod: !0
    }) : j.tokens.push({
        nested: !0,
        value: i,
        processed: !1,
        subexp: !0
    }), e += h) : j.tokens.push({
        nested: !1,
        value: g,
        processed: !1,
        subexp: !1
    });
    return j
}, ExpressionBuilder.prototype._single = function (a) {
    if (a.match(CONSTANT_RE)) return new ExpNode(null, a, pCONSTANT);
    if (a.match(OPERATOR_RE)) return new ExpNode(null, a, pOPERATOR);
    if (a.match(VARIABLE_RE)) return new ExpNode(null, a, pVARIABLE);
    throw {
        error: "unrecognized item in Parser._single"
    }
}, ExpressionBuilder.prototype._r_make_tree = function (a) {
    var b, c, d, e = a.tokens;
    for (b = 0; b < e.length; b++) c = e[b], c.nested && !c.processed ? (c.value = this._r_make_tree(c.value), c.processed = !0, c.subexp = !0, "absmod" in c && c.absmod && (d = c.value, c.value = new ExpNode(null, "\\abs", pFUNCTION), c.value.childs = [d], d.parent = c.value)) : c.processed || (c.value = this._single(c.value), c.processed = !0, c.subexp = !1);
    return this._process_functions(a), this._process_subscripts(a), this._finish_ops(a)
}, ExpressionBuilder.prototype._finish_ops = function (a) {
    var b, c, d, e, f, g, h = [],
        i = [],
        j = a.tokens,
        k = !1;
    for (b = 0; b < j.length; b++) {
        c = j[b];
        if (!c.processed) throw {
            error: "unprocessed node t"
        };
        d = c.value, e = c.subexp, f = d.type == pCONSTANT || d.type == pVARIABLE || e, k && f && this._finish_step(h, i, new ExpNode(null, "*", pOPERATOR, e)), k = f;
        if ((b > 0 && d.type == pOPERATOR && d.token == "-" && !j[b - 1].subexp && j[b - 1].value.type == pOPERATOR && j[b - 1].value.childs.length == 0 || b == 0 && d.type == pOPERATOR && d.token == "-") && d.childs.length == 0) {
            if (b > 0 && j[b - 1].value.token == "~") throw {
                error: "cannot chain unary negations"
            };
            this._finish_step(h, i, new ExpNode(null, 0, pCONSTANT, !1)), d.token = "~"
        }
        this._finish_step(h, i, d, e), d.type == pOPERATOR && d.token == "!" && !c.subexp && j.splice(b + 1, 0, {
            nested: !1,
            value: new ExpNode(null, 0, pCONSTANT, !1),
            processed: !0,
            subexp: !0
        })
    }
    this._finish_step(h, i, new ExpNode(null, "finish", pOPERATOR, !1));
    if (i.length > 1) throw {
        error: "Missing an operator."
    };
    if (i.length == 0) throw {
        error: "Please enter an expression."
    };
    if (h.length > 0) throw {
        error: "Missing an operand."
    };
    return g = i.pop(), this._r_flatten_args_lists(g), g.flatten_negations(), g
}, ExpressionBuilder.prototype._r_flatten_args_lists = function (a) {
    var b, c, d;
    if (a.childs.length > 0) for (b = 0; b < a.childs.length; b++) this._r_flatten_args_lists(a.childs[b]);
    if (a.type == pOPERATOR && a.token == "," || a.type == pFUNCTION) {
        c = [];
        for (b = 0; b < a.childs.length; b++) if (a.childs[b].type == pOPERATOR && a.childs[b].token == ",") for (d = 0; d < a.childs[b].childs.length; d++) c.push(a.childs[b].childs[d]), a.childs[b].childs[d].parent = a;
        else c.push(a.childs[b]);
        a.childs = c
    }
}, ExpressionBuilder.prototype._finish_step = function (a, b, c, d) {
    var e, f, g, h, i, j, k;
    if (d || c.type == pCONSTANT || c.type == pVARIABLE) b.push(c);
    else {
        e = OP_PRIORITIES[c.token], f = null, a.length > 0 && (f = a[a.length - 1]);
        while (f != null && f.priority >= e) {
            a.pop(), g = f.node;
            if (b.length < 2) throw {
                error: "badly formed expression: binary operator is missing an operand."
            };
            h = b.pop(), i = b.pop(), g.childs.push(i), g.childs.push(h), i.parent = g, h.parent = g, g.token == "~" && (g.childs = [h], g.token = "-"), g.token in COMPARISON_OPS && i.token in COMPARISON_OPS && (j = new ExpNode(g, g.token, pOPERATOR), k = i.childs[1].clone(), k.parent = j, j.childs = [k, h], h.parent = j, g.token = "\\and", g.childs = [i, j], i.parent = g), b.push(g), a.length > 0 ? f = a[a.length - 1] : f = null
        }(c.type != pOPERATOR || c.token != "finish") && a.push({
            node: c,
            priority: e,
            toString: function () {
                return c.toString()
            }
        })
    }
}, ExpressionBuilder.prototype.getDerivativeForm = function (a, b) {
    var c, d;
    if (!a.processed || !b.processed) throw {
        error: "Expected nominator and denominator of fraction to be preprocessed."
    };
    return c = a.value, d = b.value, d.type != pOPERATOR || d.token != "*" || d.childs.length != 2 || d.childs[0].type != pVARIABLE || d.childs[1].type != pVARIABLE || d.childs[0].token != "d" ? null : c.type == pVARIABLE && c.token == "d" ? {
        type: "implicit",
        variant: d.childs[1].token
    } : c.type == pOPERATOR && c.token == "*" && c.childs.length == 2 && c.childs[0].type == pVARIABLE && c.childs[0].token == "d" && c.childs[1].type == pVARIABLE ? {
        type: "explicit",
        variant: d.childs[1].token,
        target: c.childs[1].token
    } : null
}, ExpressionBuilder.prototype._process_functions = function (a) {
    var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C = a.tokens,
        D = [];
    for (b = 0; b < C.length; b++) {
        c = C[b];
        if (c.value.token == "\\frac" && !c.subexp) {
            if (b + 2 >= C.length) throw {
                error: "Incomplete \\frac expression."
            };
            d = C[b + 1], e = C[b + 2];
            if (!d.nested || !e.nested) throw {
                error: "nominator and denominator of \\frac{a}{b} must be enclosed in {}."
            };
            f = this.getDerivativeForm(d, e);
            if (f != null) if (f.type == "implicit") {
                g = new ExpNode(null, f.variant, pVARIABLE), h = [], i = b + 3;
                if (i >= C.length) throw {
                    error: "Incomplete derivative expression, please include an expression after the $\\frac{d}{d" + f.variant + "}$."
                };
                do h.push(C[i]), i++;
                while (i < C.length && (C[i].value.type != pOPERATOR || C[i].subexp || C[i].value.token in OP_PRIORITIES && OP_PRIORITIES[C[i].value.token] > 0));
                if (h.length == 0) throw {
                    error: "Missing expression after integral operator."
                };
                j = this._r_make_tree(new TokenNode(null, h)), k = new ExpNode(null, "\\leibniz", pOPERATOR), k.childs = [g, j], g.parent = k, j.parent = k, D.push({
                    nested: !1,
                    processed: !0,
                    value: k,
                    subexp: !0
                }), b = i - 1
            } else {
                g = new ExpNode(null, f.variant, pVARIABLE), j = new ExpNode(null, f.target, pVARIABLE);
                if (b + 3 >= C.length) throw {
                    error: "Incomplete derivative expression, please include parameters for the differentiated function $\\frac{d" + f.target + "}{d" + f.variant + "}$."
                };
                l = C[b + 3].value, k = new ExpNode(null, "\\partial", pOPERATOR), k.childs.push(g), k.childs.push(j), k.childs.push(l), g.parent = k, j.parent = k, l.parent = k, D.push({
                    nested: !1,
                    processed: !0,
                    value: k,
                    subexp: !0
                }), b += 3
            } else k = new ExpNode(null, "/", pOPERATOR), k.childs.push(d.value), k.childs.push(e.value), d.value.parent = k, e.value.parent = k, D.push({
                nested: !1,
                processed: !0,
                value: k,
                subexp: !0
            }), b += 2
        } else if (c.value.token == "\\sqrt" && !c.subexp) {
            if (b + 1 >= C.length) throw {
                error: "Incomplete \\sqrt expression."
            };
            m = C[b + 1];
            if (!m.nested) throw {
                error: "arg of $\\sqrt{${arg} must be enclosed in {}."
            };
            k = new ExpNode(null, "^", pOPERATOR), n = new ExpNode(k, .5, pCONSTANT), m.value.parent = k, k.childs.push(m.value), k.childs.push(n), D.push({
                nested: !1,
                processed: !0,
                value: k,
                subexp: !0
            }), b += 1
        } else if (c.value.token == "\\partial" && !c.subexp) {
            if (b + 4 >= C.length) throw {
                error: "Incomplete $\\partial$ expression."
            };
            o = C[b + 1], p = C[b + 2], m = C[b + 3], q = C[b + 4];
            if (o.value.token != "_" || p.value.type != pVARIABLE && (p.value.type != pOPERATOR || p.value.token != "_") || m.value.type != pVARIABLE && m.value.type != pFUNCTION) throw {
                error: "Invalid object to numerically differentiate."
            };
            k = new ExpNode(null, "\\partial", pOPERATOR), k.childs.push(p.value), k.childs.push(m.value), k.childs.push(q.value), p.value.parent = k, m.value.parent = k, q.value.parent = k, D.push({
                nested: !1,
                processed: !0,
                value: k,
                subexp: !0
            }), b += 4
        } else if (c.value.token == "\\int" && !c.subexp) {
            if (b + 7 >= C.length) throw {
                error: "Incomplete integral expression."
            };
            r = C[b + 1], s = C[b + 2], t = C[b + 3], u = C[b + 4];
            if (!(r.value.token == "^" && t.value.token == "_" || r.value.token == "_" && t.value.token == "^")) throw {
                error: "$\\int$ expression is missing ^ and _ arguments."
            };
            h = [], i = b + 5;
            for (; i + 2 < C.length; i++) {
                if (C[i].value.token == "d") break;
                h.push(C[i])
            }
            v = this._r_make_tree(new TokenNode(null, h)), w = C[i];
            if (w.value.token != "d") throw {
                error: "Expected $dx$ part of integral expression."
            };
            x = C[i + 1];
            if (x.value.type != pVARIABLE && (p.value.type != pOPERATOR || p.value.token != "_")) throw {
                error: "Expected variable expression as indepedent variable."
            };
            k = new ExpNode(null, "\\int", pOPERATOR), k.childs.push(x.value), r.value.token == "^" ? (k.childs.push(u.value), k.childs.push(s.value)) : (k.childs.push(s.value), k.childs.push(u.value)), k.childs.push(v);
            for (y = 0; y < k.childs.length; y++) k.childs[y].parent = k;
            D.push({
                nested: !1,
                processed: !0,
                value: k,
                subexp: !0
            }), b = i + 2
        } else if (c.value.token != "\\sum" && c.value.token != "\\prod" || !! c.subexp) D.push(c);
        else {
            if (b + 5 >= C.length) throw {
                error: "Incomplete $" + c.value.token + "$ expression."
            };
            r = C[b + 1], s = C[b + 2], t = C[b + 3], u = C[b + 4];
            if (!(r.value.token == "^" && t.value.token == "_" || r.value.token == "_" && t.value.token == "^")) throw {
                error: "$" + c.value.token + "$ expression is missing ^ and _ arguments."
            };
            h = [], i = b + 5;
            do h.push(C[i]), i++;
            while (i < C.length && (C[i].value.type != pOPERATOR || C[i].subexp || C[i].value.token in OP_PRIORITIES && OP_PRIORITIES[C[i].value.token] > 0));
            v = this._r_make_tree(new TokenNode(null, h)), k = new ExpNode(null, c.value.token, pOPERATOR), r.value.token == "^" ? (k.childs.push(u.value), k.childs.push(s.value)) : (k.childs.push(s.value), k.childs.push(u.value)), k.childs.push(v);
            for (y = 0; y < k.childs.length; y++) k.childs[y].parent = k;
            D.push({
                nested: !1,
                processed: !0,
                value: k,
                subexp: !0
            }), b = i - 1
        }
    }
    C = D, D = [], z = 0;
    for (z = 1; z < C.length; z++) {
        c = C[z - 1], A = C[z];
        if (c.value.token.toString().match(OPERATOR_RE)) D.push(c);
        else if (A.nested && !c.nested && (c.value.token.toString().match(FUNCTION_RE) && !(c.value.token.toString() in FUNCTION_NAME_EXCEPTIONS) || c.value.token.toString().match(VARIABLE_RE)) || !A.nested && !c.nested && c.value.token.toString().match(FUNCTION_RE) && !(c.value.token.toString() in FUNCTION_NAME_EXCEPTIONS) && (A.value.token.toString().match(VARIABLE_RE) || A.value.token.toString().match(CONSTANT_RE)) && !c.subexp) {
            k = new ExpNode(null, c.value.token, pFUNCTION);
            if (!A.nested && !A.subexp && z + 1 < C.length && C[z + 1].value.token.toString() == "^") throw {
                error: "Ambiguous expression. Formulas like $sin x^2$ should be written as $sin(x^2)$, $sin(x)^2$, or $sin^2 x$."
            };
            k.childs.push(A.value), A.value.parent = k, D.push({
                nested: !1,
                processed: !0,
                value: k,
                subexp: !0
            }), z++
        } else if (z + 2 < C.length && !c.nested && !A.nested && A.value.token == "^" && !c.subexp && (!C[z + 2].nested && c.value.token.toString().match(FUNCTION_RE) && !(c.value.token.toString() in FUNCTION_NAME_EXCEPTIONS) && (C[z + 2].value.token.toString().match(VARIABLE_RE) || C[z + 2].value.token.toString().match(CONSTANT_RE)) || C[z + 2].nested && (c.value.token.toString().match(FUNCTION_RE) && !(c.value.token.toString() in FUNCTION_NAME_EXCEPTIONS) || c.value.token.toString().match(VARIABLE_RE)))) {
            if (!(c.value.token in ALLOW_EXPONENTIAL_DECORATOR)) throw {
                error: "Did you mean to exponentiate? Example: $(" + c.value.token.toString().replace(/\\/g, "") + "(x))^2$"
            };
            B = C[z + 1].value, k = new ExpNode(null, c.value.token, pFUNCTION), k.exp_node = C[z + 1].value, k.childs.push(C[z + 2].value), C[z + 2].value.parent = k;
            if (!C[z + 2].nested && z + 3 < C.length && C[z + 3].value.token.toString() == "^") throw {
                error: "Ambiguous expression. Formulas like $sin^2 x^2$ should be written as $sin^2(x^2)$."
            };
            (B.type == pOPERATOR && B.token == "-" && B.childs.length == 1 && B.childs[0].type == pCONSTANT && B.childs[0].token == 1 || B.type == pCONSTANT && B.token == 1 && B.neg_mod || B.type == pCONSTANT && B.token == -1 && !B.neg_mod) && c.value.token in IMPLICIT_INVERSES && (k.token = IMPLICIT_INVERSES[k.token], k.exp_node = null), D.push({
                nested: !1,
                processed: !0,
                value: k,
                subexp: !0
            }), z += 3
        } else D.push(c)
    }
    z == C.length && D.push(C[z - 1]), a.tokens = D
}, ExpressionBuilder.prototype._process_subscripts = function (a) {
    var b, c, d, e, f, g = a.tokens,
        h = [g[0]];
    if (g.length < 1) return;
    if (g[0].value.token == "_" || g[g.length - 1].value.token == "_") throw {
        error: "Subscript cannot appear at beginning or end of sub-expression."
    };
    b = 1;
    for (b = 1; b < g.length - 1; b++) c = g[b], c.value.type != pOPERATOR || c.value.token != "_" ? h.push(c) : (d = h.pop(), e = g[b + 1], f = new ExpNode(null, "_", pOPERATOR), f.childs.push(d.value), f.childs.push(e.value), h.push({
        nested: !1,
        processed: !0,
        value: f,
        subexp: !0
    }), b++);
    b == g.length - 1 && h.push(g[g.length - 1]), a.tokens = h
}, ExpressionBuilder.prototype._process_factorials = function () {}, ExpressionBuilder.prototype._is_alias_list = function (a) {
    return a.type == pVARIABLE ? !0 : a.type == pOPERATOR && a.token == "," && a.childs.length == 2 ? this._is_alias_list(a.childs[0]) && this._is_alias_list(a.childs[1]) : !1
}, ExpressionBuilder.prototype._r_get_aliases = function (a, b, c, d) {
    var e, f;
    for (e = 0; e < a.childs.length; e++) {
        f = a.childs[e].token;
        if (f == c) throw {
            error: "alias in function definition cannot be same name as assignment variable"
        };
        if (f in d) throw {
            error: "token already defined in alias list"
        };
        b.push(f), d[f] = !0
    }
}, ExpressionBuilder.prototype._is_function_definition_arglist = function (a) {
    var b, c;
    if (a.length < 1) return !1;
    for (b = 0; b < a.length; b++) {
        c = a[b];
        if (c.type != pVARIABLE) {
            if (c.type != pOPERATOR || c.token != ",") return !1;
            if (!this._is_function_definition_arglist(c.childs)) return !1
        }
    }
    return !0
}, ExpressionBuilder.deplist_contains = function (a, b) {
    var c;
    for (c = 0; c < a.length; c++) if (a[c] == b) return !0;
    return !1
}, ExpressionBuilder.prototype._r_analyze = function (a, b, c, d, e, f, g) {
    var h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w = null;
    g != null && (w = g), h = !1, i = {}, j = {};
    for (k = 0; k < b.length; k++) j[b[k]] = !0;
    for (k = 0; k < c.length; k++) i[c[k]] = !0;
    l = null, m = !1;
    if (e && a.type == pOPERATOR && a.token in COMPARISON_OPS) {
        l = a.token, n = a.childs[0];
        if (n.type == pVARIABLE && !n.neg_mod && n.exp_node == null) {
            o = n.token, this._r_analyze(a.childs[1], b, c, d, !1, f, o);
            for (k = 0; k < b.length; k++) b[k] == o && (o = null, m = !0);
            w = o
        } else if (n.type == pFUNCTION && !n.neg_mod && n.exp_node == null && this._is_function_definition_arglist(n.childs)) {
            o = n.token, this._r_get_aliases(n, c, w, i), h = !0, this._r_analyze(a.childs[1], b, c, d, !1, f, o);
            for (k = 0; k < b.length; k++) b[k] == o && (o = null, m = !0);
            w = o
        } else {
            p = [], q = [], this._r_analyze(a.childs[0], p, c, d, !1, f, w), this._r_analyze(a.childs[1], q, c, d, !1, f, w), hasCommonElement(p, q) && (m = !0);
            for (k = 0; k < p.length; k++)!(p[k] in j) && !(p[k] in f && f[p[k]]) && (b.push(p[k]), j[p[k]] = !0);
            for (k = 0; k < q.length; k++)!(q[k] in j) && !(q[k] in f && f[q[k]]) && (b.push(q[k]), j[q[k]] = !0)
        }
    } else if (a.type == pVARIABLE) a.token in i || !(a.token in j) && !(a.token in f && f[a.token]) && (b.push(a.token), j[a.token] = !0);
    else if (a.type != pOPERATOR || a.token != "\\sum" && a.token != "\\prod") if (a.type == pOPERATOR && a.token == "\\int") {
        u = a.childs[0];
        if (u.type != pVARIABLE) throw {
            error: "must specify an integral iterator variable."
        };
        if (u.token == w || u.token in i || u.token in j) throw {
            error: "integral iterator variable can't also be used as an assignment, dependency, or alias variable in the same expression."
        };
        this._r_analyze(a.childs[1], b, c, d, !1, f, w), this._r_analyze(a.childs[2], b, c, d, !1, f, w);
        if (ExpressionBuilder.deplist_contains(b, u.token) || ExpressionBuilder.deplist_contains(c, u.token)) throw {
            error: "The independent variable of an integral cannot appear in the limits of the integral."
        };
        f[u.token] = !0, this._r_analyze(a.childs[3], b, c, d, !1, f, w), f[u.token] = !1
    } else if (a.type == pOPERATOR && a.token == "\\partial") {
        u = a.childs[0], v = a.childs[1], t = a.childs[2];
        if (u.type != pVARIABLE) throw {
            error: "partial's variable of differentiation must be a variable."
        };
        if (v.type != pVARIABLE) throw {
            error: "partial's target of differentiation must be a variable referencing a function."
        };
        this._r_analyze(v, b, c, d, !1, f, w), this._r_analyze(t, b, c, d, !1, f, w)
    } else if (a.type == pOPERATOR && a.token == "\\leibniz") v = a.childs[1], this._r_analyze(v, b, c, d, !1, f, w);
    else {
        if (a.type == pFUNCTION) {
            if (a.token == w) throw {
                error: "dependent variable on right side of '=' cannot also be the assignment variable."
            };
            a.token in i || !(a.token in j) && !(a.token in f && f[a.token]) && (b.push(a.token), j[a.token] = !0)
        }
        for (k = 0; k < a.childs.length; k++) this._r_analyze(a.childs[k], b, c, d, !1, f, w)
    } else {
        r = a.childs[0], s = a.childs[1], t = a.childs[2];
        if (r.type != pOPERATOR || r.token != "=" || r.childs[0].type != pVARIABLE || r.childs[0].token == w || r.childs[0].token in i || r.childs[0].token in j) throw {
            error: "summation/product iterator variable can't also be used as an assignment, dependency or alias variable in the same expression."
        };
        f[r.childs[0].token] = !0, this._r_analyze(r.childs[1], b, c, d, !1, f, w), this._r_analyze(s, b, c, d, !1, f, w), this._r_analyze(t, b, c, d, !1, f, w), f[r.childs[0].token] = !1
    }
    return {
        assignment: w,
        is_function: h,
        comparer: l,
        self_reference: m
    }
}, ExpressionBuilder.prototype._r_postprocess = function () {}, ExpressionBuilder.prototype.recovery_parse = function (a) {
    var b, c, d = null,
        e = 0;
    for (b = 0; b < a.length; b++) {
        c = a[b];
        switch (e) {
        case 0:
            if (!c.match(VARIABLE_RE)) throw {
                error: "Cannot recover fallback parser: badly formed l-value",
                state: e
            };
            d = c, e = 1;
            break;
        case 1:
            if (c == "=") return this.recovered_assignment(d);
            if (c != "(" && c != "\\left(") throw {
                error: "Cannot recover fallback parser: badly formed l-value",
                state: e
            };
            e = 2;
            break;
        case 2:
            if (c == ")" || c == "\\right)") e = 3;
            else {
                if (!c.match(VARIABLE_RE)) throw {
                    error: "Cannot recover fallback parser: badly formed l-value",
                    state: e
                };
                e = 4
            }
            break;
        case 3:
            if (c == "=") return this.recovered_assignment(d);
            throw {
                error: "Cannot recover fallback parser: badly formed l-value",
                state: e
            };
        case 4:
            if (c == ")" || c == "\\right)") e = 3;
            else {
                if (c != ",") throw {
                    error: "Cannot recover fallback parser: badly formed l-value",
                    state: e
                };
                e = 5
            }
            break;
        case 5:
            if (!c.match(VARIABLE_RE)) throw {
                error: "Cannot recover fallback parser: badly formed l-value",
                state: e
            };
            e = 4;
            break;
        default:
            throw {
                error: "Cannot recover fallback parser: invalid parser state"
            }
        }
    }
    throw {
        error: "Cannot recover fallback parser: did not find attempted variable or function assignment"
    }
}, ExpressionBuilder.prototype.recovered_assignment = function (a) {
    var b = new ExpNode(null, "=", pOPERATOR),
        c = new ExpNode(b, a, pVARIABLE),
        d = new ExpNode(b, "\\*invalid", pVARIABLE);
    return b.childs.push(c), b.childs.push(d), b
};